// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_AI_Imaging_H
#define WINRT_Microsoft_Windows_AI_Imaging_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Windows.AI.h"
#include "winrt/impl/Microsoft.Graphics.Imaging.2.h"
#include "winrt/impl/Microsoft.Windows.AI.2.h"
#include "winrt/impl/Microsoft.Windows.AI.ContentSafety.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Windows.Graphics.Imaging.2.h"
#include "winrt/impl/Microsoft.Windows.AI.Imaging.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGenerator<D>::DescribeAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& image, winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionKind const& kind, winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const& contentFilterOptions) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DescribeAsync(*(void**)(&image), static_cast<int32_t>(kind), *(void**)(&contentFilterOptions), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>**)this;
            check_hresult(_winrt_abi_type->DescribeAsync(*(void**)(&image), static_cast<int32_t>(kind), *(void**)(&contentFilterOptions), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGeneratorStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGeneratorStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGeneratorStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionResult<D>::Description() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>**)this;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionResult<D>::Status() const
    {
        winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResultStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageForegroundExtractor<D>::GetMaskFromSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetMaskFromSoftwareBitmap(*(void**)(&softwareBitmap), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor>**)this;
            check_hresult(_winrt_abi_type->GetMaskFromSoftwareBitmap(*(void**)(&softwareBitmap), &result));
        }
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageForegroundExtractor<D>::GetMaskFromImageBuffer(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetMaskFromImageBuffer(*(void**)(&imageBuffer), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor>**)this;
            check_hresult(_winrt_abi_type->GetMaskFromImageBuffer(*(void**)(&imageBuffer), &result));
        }
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageForegroundExtractorStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageForegroundExtractorStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageForegroundExtractorStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageForegroundExtractor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageFromImageGenerationOptions<D>::Style() const
    {
        winrt::Microsoft::Windows::AI::Imaging::ImageFromImageGenerationStyle value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageFromImageGenerationOptions<D>::Style(winrt::Microsoft::Windows::AI::Imaging::ImageFromImageGenerationStyle const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Style(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->put_Style(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageFromImageGenerationOptions<D>::ColorPreservation() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ColorPreservation(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->get_ColorPreservation(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageFromImageGenerationOptions<D>::ColorPreservation(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ColorPreservation(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->put_ColorPreservation(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageFromTextGenerationOptions<D>::Style() const
    {
        winrt::Microsoft::Windows::AI::Imaging::ImageFromTextGenerationStyle value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageFromTextGenerationOptions<D>::Style(winrt::Microsoft::Windows::AI::Imaging::ImageFromTextGenerationStyle const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Style(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->put_Style(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerationOptions<D>::MaxInferenceSteps() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxInferenceSteps(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->get_MaxInferenceSteps(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerationOptions<D>::MaxInferenceSteps(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaxInferenceSteps(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->put_MaxInferenceSteps(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerationOptions<D>::Creativity() const
    {
        double value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Creativity(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->get_Creativity(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerationOptions<D>::Creativity(double value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Creativity(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->put_Creativity(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerationOptions<D>::Seed() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Seed(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->get_Seed(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerationOptions<D>::Seed(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Seed(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->put_Seed(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerationOptions<D>::ContentFilterOptions() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentFilterOptions(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->get_ContentFilterOptions(&value));
        }
        return winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerationOptions<D>::ContentFilterOptions(winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ContentFilterOptions(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>**)this;
            check_hresult(_winrt_abi_type->put_ContentFilterOptions(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerator<D>::GenerateImageFromTextPrompt(param::hstring const& textPrompt, winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateImageFromTextPrompt(*(void**)(&textPrompt), *(void**)(&options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>**)this;
            check_hresult(_winrt_abi_type->GenerateImageFromTextPrompt(*(void**)(&textPrompt), *(void**)(&options), &result));
        }
        return winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerator<D>::GenerateImageFromImageBuffer(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& image, param::hstring const& textPrompt, winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateImageFromImageBuffer(*(void**)(&image), *(void**)(&textPrompt), *(void**)(&options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>**)this;
            check_hresult(_winrt_abi_type->GenerateImageFromImageBuffer(*(void**)(&image), *(void**)(&textPrompt), *(void**)(&options), &result));
        }
        return winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerator<D>::GenerateImageFromImageBufferAndMask(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& image, winrt::Microsoft::Graphics::Imaging::ImageBuffer const& mask, param::hstring const& textPrompt, winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateImageFromImageBufferAndMask(*(void**)(&image), *(void**)(&mask), *(void**)(&textPrompt), *(void**)(&options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>**)this;
            check_hresult(_winrt_abi_type->GenerateImageFromImageBufferAndMask(*(void**)(&image), *(void**)(&mask), *(void**)(&textPrompt), *(void**)(&options), &result));
        }
        return winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerator2<D>::GenerateImageFromTextPrompt(param::hstring const& textPrompt, winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const& options, winrt::Microsoft::Windows::AI::Imaging::ImageFromTextGenerationOptions const& imageFromTextGenerationOption) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateImageFromTextPrompt(*(void**)(&textPrompt), *(void**)(&options), *(void**)(&imageFromTextGenerationOption), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2>**)this;
            check_hresult(_winrt_abi_type->GenerateImageFromTextPrompt(*(void**)(&textPrompt), *(void**)(&options), *(void**)(&imageFromTextGenerationOption), &result));
        }
        return winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGenerator2<D>::GenerateImageFromImageBuffer(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& image, param::hstring const& textPrompt, winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const& options, winrt::Microsoft::Windows::AI::Imaging::ImageFromImageGenerationOptions const& imageFromImageGenerationOptions) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateImageFromImageBuffer(*(void**)(&image), *(void**)(&textPrompt), *(void**)(&options), *(void**)(&imageFromImageGenerationOptions), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2>**)this;
            check_hresult(_winrt_abi_type->GenerateImageFromImageBuffer(*(void**)(&image), *(void**)(&textPrompt), *(void**)(&options), *(void**)(&imageFromImageGenerationOptions), &result));
        }
        return winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGeneratorResult<D>::Image() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Image(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>**)this;
            check_hresult(_winrt_abi_type->get_Image(&value));
        }
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGeneratorResult<D>::Status() const
    {
        winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResultStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGeneratorResult<D>::ExtendedError() const
    {
        winrt::hresult value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>**)this;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGeneratorStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGeneratorStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageGeneratorStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageGenerator>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractor<D>::GetSoftwareBitmapObjectMask(winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const& hint) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSoftwareBitmapObjectMask(*(void**)(&hint), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>**)this;
            check_hresult(_winrt_abi_type->GetSoftwareBitmapObjectMask(*(void**)(&hint), &result));
        }
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractor<D>::GetImageBufferObjectMask(winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const& hint) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetImageBufferObjectMask(*(void**)(&hint), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>**)this;
            check_hresult(_winrt_abi_type->GetImageBufferObjectMask(*(void**)(&hint), &result));
        }
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHint<D>::IncludeRects() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IncludeRects(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)this;
            check_hresult(_winrt_abi_type->get_IncludeRects(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::RectInt32>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHint<D>::IncludePoints() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IncludePoints(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)this;
            check_hresult(_winrt_abi_type->get_IncludePoints(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHint<D>::ExcludePoints() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExcludePoints(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)this;
            check_hresult(_winrt_abi_type->get_ExcludePoints(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHintFactory<D>::CreateInstance(param::vector<winrt::Windows::Graphics::RectInt32> const& includeRects, param::vector<winrt::Windows::Graphics::PointInt32> const& includePoints, param::vector<winrt::Windows::Graphics::PointInt32> const& excludePoints) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&includeRects), *(void**)(&includePoints), *(void**)(&excludePoints), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&includeRects), *(void**)(&includePoints), *(void**)(&excludePoints), &value));
        }
        return winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::CreateWithSoftwareBitmapAsync(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithSoftwareBitmapAsync(*(void**)(&softwareBitmap), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateWithSoftwareBitmapAsync(*(void**)(&softwareBitmap), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::CreateWithImageBufferAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithImageBufferAsync(*(void**)(&imageBuffer), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateWithImageBufferAsync(*(void**)(&imageBuffer), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemover<D>::RemoveFromSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap, winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmapMask) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RemoveFromSoftwareBitmap(*(void**)(&softwareBitmap), *(void**)(&softwareBitmapMask), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>**)this;
            check_hresult(_winrt_abi_type->RemoveFromSoftwareBitmap(*(void**)(&softwareBitmap), *(void**)(&softwareBitmapMask), &result));
        }
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemover<D>::RemoveFromImageBuffer(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer, winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBufferMask) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RemoveFromImageBuffer(*(void**)(&imageBuffer), *(void**)(&imageBufferMask), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>**)this;
            check_hresult(_winrt_abi_type->RemoveFromImageBuffer(*(void**)(&imageBuffer), *(void**)(&imageBufferMask), &result));
        }
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemoverStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemoverStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectRemoverStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectRemover>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScaler<D>::ScaleSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap, int32_t width, int32_t height) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScaler, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ScaleSoftwareBitmap(*(void**)(&softwareBitmap), width, height, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)this;
            check_hresult(_winrt_abi_type->ScaleSoftwareBitmap(*(void**)(&softwareBitmap), width, height, &result));
        }
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScaler<D>::ScaleImageBuffer(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer, int32_t width, int32_t height) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScaler, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ScaleImageBuffer(*(void**)(&imageBuffer), width, height, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)this;
            check_hresult(_winrt_abi_type->ScaleImageBuffer(*(void**)(&imageBuffer), width, height, &result));
        }
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScaler<D>::MaxSupportedScaleFactor() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScaler, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxSupportedScaleFactor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)this;
            check_hresult(_winrt_abi_type->get_MaxSupportedScaleFactor(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScalerStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScalerStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScalerStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageScaler>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::Text() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::BoundingBox() const
    {
        winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::Words() const
    {
        uint32_t value_impl_size{};
        void** value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Words(&value_impl_size, &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_Words(&value_impl_size, &value));
        }
        return com_array<winrt::Microsoft::Windows::AI::Imaging::RecognizedWord>{ value, value_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::Style() const
    {
        winrt::Microsoft::Windows::AI::Imaging::RecognizedLineStyle value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::LineStyleConfidence() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LineStyleConfidence(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_LineStyleConfidence(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedText<D>::Lines() const
    {
        uint32_t value_impl_size{};
        void** value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Lines(&value_impl_size, &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)this;
            check_hresult(_winrt_abi_type->get_Lines(&value_impl_size, &value));
        }
        return com_array<winrt::Microsoft::Windows::AI::Imaging::RecognizedLine>{ value, value_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedText<D>::TextAngle() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TextAngle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)this;
            check_hresult(_winrt_abi_type->get_TextAngle(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedWord<D>::Text() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)this;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedWord<D>::BoundingBox() const
    {
        winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)this;
            check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedWord<D>::MatchConfidence() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MatchConfidence(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)this;
            check_hresult(_winrt_abi_type->get_MatchConfidence(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizer<D>::RecognizeTextFromImageAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(*(void**)(&imageBuffer), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)this;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(*(void**)(&imageBuffer), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizer<D>::RecognizeTextFromImage(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecognizeTextFromImage(*(void**)(&imageBuffer), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)this;
            check_hresult(_winrt_abi_type->RecognizeTextFromImage(*(void**)(&imageBuffer), &result));
        }
        return winrt::Microsoft::Windows::AI::Imaging::RecognizedText{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizer2<D>::RecognizeTextFromImageAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer, winrt::Microsoft::Windows::AI::Imaging::TextRecognizerOptions const& options) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(*(void**)(&imageBuffer), *(void**)(&options), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2>**)this;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(*(void**)(&imageBuffer), *(void**)(&options), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizer2<D>::RecognizeTextFromImage(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer, winrt::Microsoft::Windows::AI::Imaging::TextRecognizerOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecognizeTextFromImage(*(void**)(&imageBuffer), *(void**)(&options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2>**)this;
            check_hresult(_winrt_abi_type->RecognizeTextFromImage(*(void**)(&imageBuffer), *(void**)(&options), &result));
        }
        return winrt::Microsoft::Windows::AI::Imaging::RecognizedText{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerOptions<D>::EnableWordLevelConfidence() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EnableWordLevelConfidence(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>**)this;
            check_hresult(_winrt_abi_type->get_EnableWordLevelConfidence(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerOptions<D>::EnableWordLevelConfidence(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_EnableWordLevelConfidence(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>**)this;
            check_hresult(_winrt_abi_type->put_EnableWordLevelConfidence(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerOptions<D>::DetectorOutputGeometryMode() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DetectorOutputGeometryMode(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>**)this;
            check_hresult(_winrt_abi_type->get_DetectorOutputGeometryMode(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerOptions<D>::DetectorOutputGeometryMode(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DetectorOutputGeometryMode(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>**)this;
            check_hresult(_winrt_abi_type->put_DetectorOutputGeometryMode(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::TextRecognizer>{ operation, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>
    {
        int32_t __stdcall DescribeAsync(void* image, int32_t kind, void* contentFilterOptions, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResult, hstring>>(this->shim().DescribeAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&image), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionKind const*>(&kind), *reinterpret_cast<winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const*>(&contentFilterOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>
    {
        int32_t __stdcall get_Description(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Description());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResultStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor>
    {
        int32_t __stdcall GetMaskFromSoftwareBitmap(void* softwareBitmap, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().GetMaskFromSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetMaskFromImageBuffer(void* imageBuffer, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().GetMaskFromImageBuffer(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageForegroundExtractor>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions>
    {
        int32_t __stdcall get_Style(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageFromImageGenerationStyle>(this->shim().Style());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Style(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Style(*reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageFromImageGenerationStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ColorPreservation(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().ColorPreservation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ColorPreservation(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ColorPreservation(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions>
    {
        int32_t __stdcall get_Style(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageFromTextGenerationStyle>(this->shim().Style());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Style(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Style(*reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageFromTextGenerationStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions>
    {
        int32_t __stdcall get_MaxInferenceSteps(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxInferenceSteps());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxInferenceSteps(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxInferenceSteps(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Creativity(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Creativity());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Creativity(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Creativity(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Seed(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().Seed());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Seed(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Seed(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentFilterOptions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions>(this->shim().ContentFilterOptions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ContentFilterOptions(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ContentFilterOptions(*reinterpret_cast<winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerator> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerator>
    {
        int32_t __stdcall GenerateImageFromTextPrompt(void* textPrompt, void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult>(this->shim().GenerateImageFromTextPrompt(*reinterpret_cast<hstring const*>(&textPrompt), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GenerateImageFromImageBuffer(void* image, void* textPrompt, void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult>(this->shim().GenerateImageFromImageBuffer(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&image), *reinterpret_cast<hstring const*>(&textPrompt), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GenerateImageFromImageBufferAndMask(void* image, void* mask, void* textPrompt, void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult>(this->shim().GenerateImageFromImageBufferAndMask(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&image), *reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&mask), *reinterpret_cast<hstring const*>(&textPrompt), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2>
    {
        int32_t __stdcall GenerateImageFromTextPrompt(void* textPrompt, void* options, void* imageFromTextGenerationOption, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult>(this->shim().GenerateImageFromTextPrompt(*reinterpret_cast<hstring const*>(&textPrompt), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const*>(&options), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageFromTextGenerationOptions const*>(&imageFromTextGenerationOption)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GenerateImageFromImageBuffer(void* image, void* textPrompt, void* options, void* imageFromImageGenerationOptions, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult>(this->shim().GenerateImageFromImageBuffer(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&image), *reinterpret_cast<hstring const*>(&textPrompt), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions const*>(&options), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageFromImageGenerationOptions const*>(&imageFromImageGenerationOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult>
    {
        int32_t __stdcall get_Image(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().Image());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResultStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageGenerator>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>
    {
        int32_t __stdcall GetSoftwareBitmapObjectMask(void* hint, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().GetSoftwareBitmapObjectMask(*reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const*>(&hint)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetImageBufferObjectMask(void* hint, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().GetImageBufferObjectMask(*reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const*>(&hint)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>
    {
        int32_t __stdcall get_IncludeRects(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::RectInt32>>(this->shim().IncludeRects());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IncludePoints(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>>(this->shim().IncludePoints());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExcludePoints(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>>(this->shim().ExcludePoints());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>
    {
        int32_t __stdcall CreateInstance(void* includeRects, void* includePoints, void* excludePoints, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Graphics::RectInt32> const*>(&includeRects), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Graphics::PointInt32> const*>(&includePoints), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Graphics::PointInt32> const*>(&excludePoints)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>
    {
        int32_t __stdcall CreateWithSoftwareBitmapAsync(void* softwareBitmap, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>>(this->shim().CreateWithSoftwareBitmapAsync(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithImageBufferAsync(void* imageBuffer, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>>(this->shim().CreateWithImageBufferAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover>
    {
        int32_t __stdcall RemoveFromSoftwareBitmap(void* softwareBitmap, void* softwareBitmapMask, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().RemoveFromSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap), *reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmapMask)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemoveFromImageBuffer(void* imageBuffer, void* imageBufferMask, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().RemoveFromImageBuffer(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer), *reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBufferMask)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectRemover>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>
    {
        int32_t __stdcall ScaleSoftwareBitmap(void* softwareBitmap, int32_t width, int32_t height, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().ScaleSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ScaleImageBuffer(void* imageBuffer, int32_t width, int32_t height, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().ScaleImageBuffer(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxSupportedScaleFactor(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxSupportedScaleFactor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageScaler>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>
    {
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BoundingBox(struct struct_Microsoft_Windows_AI_Imaging_RecognizedTextBoundingBox* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(this->shim().BoundingBox());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Words(uint32_t* __valueSize, void*** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueSize, *value) = detach_abi(this->shim().Words());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Style(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedLineStyle>(this->shim().Style());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LineStyleConfidence(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().LineStyleConfidence());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>
    {
        int32_t __stdcall get_Lines(uint32_t* __valueSize, void*** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueSize, *value) = detach_abi(this->shim().Lines());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TextAngle(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().TextAngle());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>
    {
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BoundingBox(struct struct_Microsoft_Windows_AI_Imaging_RecognizedTextBoundingBox* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(this->shim().BoundingBox());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MatchConfidence(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().MatchConfidence());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>
    {
        int32_t __stdcall RecognizeTextFromImageAsync(void* imageBuffer, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>>(this->shim().RecognizeTextFromImageAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RecognizeTextFromImage(void* imageBuffer, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>(this->shim().RecognizeTextFromImage(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2>
    {
        int32_t __stdcall RecognizeTextFromImageAsync(void* imageBuffer, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>>(this->shim().RecognizeTextFromImageAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::TextRecognizerOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RecognizeTextFromImage(void* imageBuffer, void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>(this->shim().RecognizeTextFromImage(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::TextRecognizerOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions>
    {
        int32_t __stdcall get_EnableWordLevelConfidence(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().EnableWordLevelConfidence());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_EnableWordLevelConfidence(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EnableWordLevelConfidence(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DetectorOutputGeometryMode(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DetectorOutputGeometryMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DetectorOutputGeometryMode(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DetectorOutputGeometryMode(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::TextRecognizer>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::AI::Imaging
{
    inline auto ImageDescriptionGenerator::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageDescriptionGeneratorStatics const&), ImageDescriptionGenerator, IImageDescriptionGeneratorStatics>([](IImageDescriptionGeneratorStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageDescriptionGenerator::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageDescriptionGeneratorStatics const&), ImageDescriptionGenerator, IImageDescriptionGeneratorStatics>([](IImageDescriptionGeneratorStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto ImageDescriptionGenerator::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator>(*)(IImageDescriptionGeneratorStatics const&), ImageDescriptionGenerator, IImageDescriptionGeneratorStatics>([](IImageDescriptionGeneratorStatics const& f) { return f.CreateAsync(); });
    }
    inline auto ImageForegroundExtractor::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageForegroundExtractorStatics const&), ImageForegroundExtractor, IImageForegroundExtractorStatics>([](IImageForegroundExtractorStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageForegroundExtractor::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageForegroundExtractorStatics const&), ImageForegroundExtractor, IImageForegroundExtractorStatics>([](IImageForegroundExtractorStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto ImageForegroundExtractor::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageForegroundExtractor>(*)(IImageForegroundExtractorStatics const&), ImageForegroundExtractor, IImageForegroundExtractorStatics>([](IImageForegroundExtractorStatics const& f) { return f.CreateAsync(); });
    }
    inline ImageFromImageGenerationOptions::ImageFromImageGenerationOptions() :
        ImageFromImageGenerationOptions(impl::call_factory_cast<ImageFromImageGenerationOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), ImageFromImageGenerationOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ImageFromImageGenerationOptions>(); }))
    {
    }
    inline ImageFromTextGenerationOptions::ImageFromTextGenerationOptions() :
        ImageFromTextGenerationOptions(impl::call_factory_cast<ImageFromTextGenerationOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), ImageFromTextGenerationOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ImageFromTextGenerationOptions>(); }))
    {
    }
    inline ImageGenerationOptions::ImageGenerationOptions() :
        ImageGenerationOptions(impl::call_factory_cast<ImageGenerationOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), ImageGenerationOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ImageGenerationOptions>(); }))
    {
    }
    inline auto ImageGenerator::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageGeneratorStatics const&), ImageGenerator, IImageGeneratorStatics>([](IImageGeneratorStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageGenerator::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageGeneratorStatics const&), ImageGenerator, IImageGeneratorStatics>([](IImageGeneratorStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto ImageGenerator::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageGenerator>(*)(IImageGeneratorStatics const&), ImageGenerator, IImageGeneratorStatics>([](IImageGeneratorStatics const& f) { return f.CreateAsync(); });
    }
    inline auto ImageObjectExtractor::CreateWithSoftwareBitmapAsync(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap)
    {
        return impl::call_factory<ImageObjectExtractor, IImageObjectExtractorStatics>([&](IImageObjectExtractorStatics const& f) { return f.CreateWithSoftwareBitmapAsync(softwareBitmap); });
    }
    inline auto ImageObjectExtractor::CreateWithImageBufferAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer)
    {
        return impl::call_factory<ImageObjectExtractor, IImageObjectExtractorStatics>([&](IImageObjectExtractorStatics const& f) { return f.CreateWithImageBufferAsync(imageBuffer); });
    }
    inline auto ImageObjectExtractor::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageObjectExtractorStatics const&), ImageObjectExtractor, IImageObjectExtractorStatics>([](IImageObjectExtractorStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageObjectExtractor::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageObjectExtractorStatics const&), ImageObjectExtractor, IImageObjectExtractorStatics>([](IImageObjectExtractorStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline ImageObjectExtractorHint::ImageObjectExtractorHint(param::vector<winrt::Windows::Graphics::RectInt32> const& includeRects, param::vector<winrt::Windows::Graphics::PointInt32> const& includePoints, param::vector<winrt::Windows::Graphics::PointInt32> const& excludePoints) :
        ImageObjectExtractorHint(impl::call_factory<ImageObjectExtractorHint, IImageObjectExtractorHintFactory>([&](IImageObjectExtractorHintFactory const& f) { return f.CreateInstance(includeRects, includePoints, excludePoints); }))
    {
    }
    inline auto ImageObjectRemover::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageObjectRemoverStatics const&), ImageObjectRemover, IImageObjectRemoverStatics>([](IImageObjectRemoverStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageObjectRemover::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageObjectRemoverStatics const&), ImageObjectRemover, IImageObjectRemoverStatics>([](IImageObjectRemoverStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto ImageObjectRemover::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectRemover>(*)(IImageObjectRemoverStatics const&), ImageObjectRemover, IImageObjectRemoverStatics>([](IImageObjectRemoverStatics const& f) { return f.CreateAsync(); });
    }
    inline auto ImageScaler::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageScalerStatics const&), ImageScaler, IImageScalerStatics>([](IImageScalerStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageScaler::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageScalerStatics const&), ImageScaler, IImageScalerStatics>([](IImageScalerStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto ImageScaler::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageScaler>(*)(IImageScalerStatics const&), ImageScaler, IImageScalerStatics>([](IImageScalerStatics const& f) { return f.CreateAsync(); });
    }
    inline auto TextRecognizer::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(ITextRecognizerStatics const&), TextRecognizer, ITextRecognizerStatics>([](ITextRecognizerStatics const& f) { return f.GetReadyState(); });
    }
    inline auto TextRecognizer::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(ITextRecognizerStatics const&), TextRecognizer, ITextRecognizerStatics>([](ITextRecognizerStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto TextRecognizer::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::TextRecognizer>(*)(ITextRecognizerStatics const&), TextRecognizer, ITextRecognizerStatics>([](ITextRecognizerStatics const& f) { return f.CreateAsync(); });
    }
    inline TextRecognizerOptions::TextRecognizerOptions() :
        TextRecognizerOptions(impl::call_factory_cast<TextRecognizerOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), TextRecognizerOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<TextRecognizerOptions>(); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageForegroundExtractorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageFromImageGenerationOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageFromTextGenerationOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageGenerationOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageGenerator2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageGeneratorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemover> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectRemoverStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageScaler> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageForegroundExtractor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageFromImageGenerationOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageFromTextGenerationOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageGenerationOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageGenerator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageGeneratorResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageObjectRemover> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageScaler> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::RecognizedLine> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::RecognizedText> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::RecognizedWord> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::TextRecognizer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::TextRecognizerOptions> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
