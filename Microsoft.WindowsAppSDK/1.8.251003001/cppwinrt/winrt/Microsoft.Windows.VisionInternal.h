// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_VisionInternal_H
#define WINRT_Microsoft_Windows_VisionInternal_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Windows.PrivateCommon.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Microsoft.Windows.VisionInternal.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_VisionInternal_IRecognizedTextInternal<D>::GetDataLength() const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDataLength(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>**)this;
            check_hresult(_winrt_abi_type->GetDataLength(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_VisionInternal_IRecognizedTextInternal<D>::GetData(array_view<uint8_t> buffer) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetData(buffer.size(), put_abi(buffer)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>**)this;
            check_hresult(_winrt_abi_type->GetData(buffer.size(), put_abi(buffer)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_VisionInternal_IScreenRegionDetectorSession<D>::GetScreenRegionsAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& inputImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& inputImageBufferViewData) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetScreenRegionsAsync(impl::bind_in(inputImageBufferView), impl::bind_in(inputImageBufferViewData), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession>**)this;
            check_hresult(_winrt_abi_type->GetScreenRegionsAsync(impl::bind_in(inputImageBufferView), impl::bind_in(inputImageBufferViewData), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::VisionInternal::ScreenRegionInternal>>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_VisionInternal_IScreenRegionDetectorSession2<D>::GetScreenRegionsAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& inputImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& inputImageBufferViewData, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetScreenRegionsAsync(impl::bind_in(inputImageBufferView), impl::bind_in(inputImageBufferViewData), priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession2>**)this;
            check_hresult(_winrt_abi_type->GetScreenRegionsAsync(impl::bind_in(inputImageBufferView), impl::bind_in(inputImageBufferViewData), priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::VisionInternal::ScreenRegionInternal>>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_VisionInternal_IScreenRegionDetectorSession3<D>::GetScreenRegions(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, uint32_t priority, uint32_t frequency) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetScreenRegions(*(void**)(&inputImageBufferResource), priority, frequency, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession3>**)this;
            check_hresult(_winrt_abi_type->GetScreenRegions(*(void**)(&inputImageBufferResource), priority, frequency, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::VisionInternal::ScreenRegionInternal>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_VisionInternal_IScreenRegionDetectorSession4<D>::GetScreenRegions4(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, uint32_t priority, uint32_t frequency) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetScreenRegions4(*(void**)(&inputImageBufferResource), priority, frequency, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession4>**)this;
            check_hresult(_winrt_abi_type->GetScreenRegions4(*(void**)(&inputImageBufferResource), priority, frequency, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::VisionInternal::ScreenRegionInternal4>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_VisionInternal_ITextRecognizerSession<D>::RecognizeTextFromImageAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& imageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& imageBufferViewData, winrt::Microsoft::Windows::VisionInternal::TextRecognizerOptionsInternal const& options) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(impl::bind_in(imageBufferView), impl::bind_in(imageBufferViewData), impl::bind_in(options), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession>**)this;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(impl::bind_in(imageBufferView), impl::bind_in(imageBufferViewData), impl::bind_in(options), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_VisionInternal_ITextRecognizerSession2<D>::RecognizeTextFromImageAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& imageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& imageBufferViewData, winrt::Microsoft::Windows::VisionInternal::TextRecognizerOptionsInternal const& options, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(impl::bind_in(imageBufferView), impl::bind_in(imageBufferViewData), impl::bind_in(options), priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession2>**)this;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(impl::bind_in(imageBufferView), impl::bind_in(imageBufferViewData), impl::bind_in(options), priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_VisionInternal_ITextRecognizerSession3<D>::RecognizeTextFromImage(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& imageBufferResource, winrt::Microsoft::Windows::VisionInternal::TextRecognizerOptionsInternal const& options, uint32_t priority, uint32_t frequency) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecognizeTextFromImage(*(void**)(&imageBufferResource), impl::bind_in(options), priority, frequency, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession3>**)this;
            check_hresult(_winrt_abi_type->RecognizeTextFromImage(*(void**)(&imageBufferResource), impl::bind_in(options), priority, frequency, &result));
        }
        return winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal{ result, take_ownership_from_abi };
    }
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal> : produce_base<D, winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>
    {
        int32_t __stdcall GetDataLength(uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().GetDataLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetData(uint32_t __bufferSize, uint8_t* buffer) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GetData(array_view<uint8_t>(reinterpret_cast<uint8_t*>(buffer), reinterpret_cast<uint8_t*>(buffer) + __bufferSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession> : produce_base<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession>
    {
        int32_t __stdcall GetScreenRegionsAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView inputImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData inputImageBufferViewData, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::VisionInternal::ScreenRegionInternal>>>(this->shim().GetScreenRegionsAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&inputImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&inputImageBufferViewData)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession2> : produce_base<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession2>
    {
        int32_t __stdcall GetScreenRegionsAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView inputImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData inputImageBufferViewData, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::VisionInternal::ScreenRegionInternal>>>(this->shim().GetScreenRegionsAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&inputImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&inputImageBufferViewData), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession3> : produce_base<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession3>
    {
        int32_t __stdcall GetScreenRegions(void* inputImageBufferResource, uint32_t priority, uint32_t frequency, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::VisionInternal::ScreenRegionInternal>>(this->shim().GetScreenRegions(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession4> : produce_base<D, winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession4>
    {
        int32_t __stdcall GetScreenRegions4(void* inputImageBufferResource, uint32_t priority, uint32_t frequency, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::VisionInternal::ScreenRegionInternal4>>(this->shim().GetScreenRegions4(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession> : produce_base<D, winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession>
    {
        int32_t __stdcall RecognizeTextFromImageAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView imageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData imageBufferViewData, struct struct_Microsoft_Windows_VisionInternal_TextRecognizerOptionsInternal options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>>(this->shim().RecognizeTextFromImageAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&imageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&imageBufferViewData), *reinterpret_cast<winrt::Microsoft::Windows::VisionInternal::TextRecognizerOptionsInternal const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession2> : produce_base<D, winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession2>
    {
        int32_t __stdcall RecognizeTextFromImageAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView imageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData imageBufferViewData, struct struct_Microsoft_Windows_VisionInternal_TextRecognizerOptionsInternal options, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>>(this->shim().RecognizeTextFromImageAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&imageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&imageBufferViewData), *reinterpret_cast<winrt::Microsoft::Windows::VisionInternal::TextRecognizerOptionsInternal const*>(&options), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession3> : produce_base<D, winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession3>
    {
        int32_t __stdcall RecognizeTextFromImage(void* imageBufferResource, struct struct_Microsoft_Windows_VisionInternal_TextRecognizerOptionsInternal options, uint32_t priority, uint32_t frequency, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal>(this->shim().RecognizeTextFromImage(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&imageBufferResource), *reinterpret_cast<winrt::Microsoft::Windows::VisionInternal::TextRecognizerOptionsInternal const*>(&options), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::VisionInternal
{
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::VisionInternal::IRecognizedTextInternal> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::VisionInternal::IScreenRegionDetectorSession4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::VisionInternal::ITextRecognizerSession3> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
