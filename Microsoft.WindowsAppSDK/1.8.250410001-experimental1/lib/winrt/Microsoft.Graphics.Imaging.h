// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.240405.15

#pragma once
#ifndef WINRT_Microsoft_Graphics_Imaging_H
#define WINRT_Microsoft_Graphics_Imaging_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.240405.15"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.240405.15"
#include "winrt/impl/Microsoft.Windows.AI.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Windows.Graphics.Imaging.2.h"
#include "winrt/impl/Windows.Storage.Streams.2.h"
#include "winrt/impl/Microsoft.Graphics.Imaging.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::CreateSoftwareBitmap() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBuffer)->CreateSoftwareBitmap(&result));
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::Buffer() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBuffer)->get_Buffer(&value));
        return winrt::Windows::Storage::Streams::IBuffer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::PixelFormat() const
    {
        winrt::Microsoft::Graphics::Imaging::PixelFormat value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBuffer)->get_PixelFormat(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::Height() const
    {
        uint32_t value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBuffer)->get_Height(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::Width() const
    {
        uint32_t value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBuffer)->get_Width(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::BufferLength() const
    {
        uint32_t value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBuffer)->get_BufferLength(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::CopyToBuffer(array_view<uint8_t> values) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBuffer)->CopyToBuffer(values.size(), put_abi(values)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBufferFactory<D>::CreateInstance(winrt::Windows::Storage::Streams::IBuffer const& buffer, winrt::Microsoft::Graphics::Imaging::PixelFormat const& pixelFormat, uint32_t width, uint32_t height) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBufferFactory)->CreateInstance(*(void**)(&buffer), static_cast<int32_t>(pixelFormat), width, height, &value));
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBufferStatics<D>::CreateCopyFromBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBufferStatics)->CreateCopyFromBitmap(*(void**)(&softwareBitmap), &result));
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBufferStatics<D>::CreateBufferAttachedToBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBufferStatics)->CreateBufferAttachedToBitmap(*(void**)(&softwareBitmap), &result));
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBufferStatics2<D>::CreateFromBuffer(winrt::Windows::Storage::Streams::IBuffer const& buffer, winrt::Microsoft::Graphics::Imaging::PixelFormat const& pixelFormat, uint32_t width, uint32_t height) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBufferStatics2)->CreateFromBuffer(*(void**)(&buffer), static_cast<int32_t>(pixelFormat), width, height, &result));
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBufferStatics2<D>::CreateFromBufferWithStride(winrt::Windows::Storage::Streams::IBuffer const& buffer, winrt::Microsoft::Graphics::Imaging::PixelFormat const& pixelFormat, uint32_t width, uint32_t height, uint32_t stride) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageBufferStatics2)->CreateFromBufferWithStride(*(void**)(&buffer), static_cast<int32_t>(pixelFormat), width, height, stride, &result));
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractor<D>::GetSoftwareBitmapObjectMask(winrt::Microsoft::Graphics::Imaging::ImageObjectExtractorHint const& hint) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractor)->GetSoftwareBitmapObjectMask(*(void**)(&hint), &result));
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractor<D>::GetImageBufferObjectMask(winrt::Microsoft::Graphics::Imaging::ImageObjectExtractorHint const& hint) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractor)->GetImageBufferObjectMask(*(void**)(&hint), &result));
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractorHint<D>::IncludeRects() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHint)->get_IncludeRects(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::RectInt32>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractorHint<D>::IncludePoints() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHint)->get_IncludePoints(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractorHint<D>::ExcludePoints() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHint)->get_ExcludePoints(&value));
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractorHintFactory<D>::CreateInstance(param::vector<winrt::Windows::Graphics::RectInt32> const& includeRects, param::vector<winrt::Windows::Graphics::PointInt32> const& includePoints, param::vector<winrt::Windows::Graphics::PointInt32> const& excludePoints) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHintFactory)->CreateInstance(*(void**)(&includeRects), *(void**)(&includePoints), *(void**)(&excludePoints), &value));
        return winrt::Microsoft::Graphics::Imaging::ImageObjectExtractorHint{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractorStatics<D>::CreateWithSoftwareBitmapAsync(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorStatics)->CreateWithSoftwareBitmapAsync(*(void**)(&softwareBitmap), &operation));
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageObjectExtractor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractorStatics<D>::CreateWithImageBufferAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorStatics)->CreateWithImageBufferAsync(*(void**)(&imageBuffer), &operation));
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageObjectExtractor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractorStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorStatics)->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        return result;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectExtractorStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorStatics)->EnsureReadyAsync(&operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectRemover<D>::RemoveFromSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap, winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmapMask) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectRemover)->RemoveFromSoftwareBitmap(*(void**)(&softwareBitmap), *(void**)(&softwareBitmapMask), &result));
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectRemover<D>::RemoveFromImageBuffer(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer, winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBufferMask) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectRemover)->RemoveFromImageBuffer(*(void**)(&imageBuffer), *(void**)(&imageBufferMask), &result));
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectRemoverStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectRemoverStatics)->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        return result;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectRemoverStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectRemoverStatics)->EnsureReadyAsync(&operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageObjectRemoverStatics<D>::CreateAsync() const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageObjectRemoverStatics)->CreateAsync(&operation));
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageObjectRemover>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageScaler<D>::ScaleSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap, int32_t width, int32_t height) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageScaler)->ScaleSoftwareBitmap(*(void**)(&softwareBitmap), width, height, &result));
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageScaler<D>::ScaleImageBuffer(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer, int32_t width, int32_t height) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageScaler)->ScaleImageBuffer(*(void**)(&imageBuffer), width, height, &result));
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageScaler<D>::MaxSupportedScaleFactor() const
    {
        int32_t value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageScaler)->get_MaxSupportedScaleFactor(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageScalerStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageScalerStatics)->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        return result;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageScalerStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageScalerStatics)->EnsureReadyAsync(&operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageScalerStatics<D>::CreateAsync() const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Imaging::IImageScalerStatics)->CreateAsync(&operation));
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageScaler>{ operation, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>
    {
        int32_t __stdcall CreateSoftwareBitmap(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().CreateSoftwareBitmap());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Buffer(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Streams::IBuffer>(this->shim().Buffer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PixelFormat(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Imaging::PixelFormat>(this->shim().PixelFormat());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Height(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().Height());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Width(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().Width());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BufferLength(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().BufferLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CopyToBuffer(uint32_t __valuesSize, uint8_t* values) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CopyToBuffer(array_view<uint8_t>(reinterpret_cast<uint8_t*>(values), reinterpret_cast<uint8_t*>(values) + __valuesSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageBufferFactory> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageBufferFactory>
    {
        int32_t __stdcall CreateInstance(void* buffer, int32_t pixelFormat, uint32_t width, uint32_t height, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer), *reinterpret_cast<winrt::Microsoft::Graphics::Imaging::PixelFormat const*>(&pixelFormat), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageBufferStatics> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>
    {
        int32_t __stdcall CreateCopyFromBitmap(void* softwareBitmap, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().CreateCopyFromBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateBufferAttachedToBitmap(void* softwareBitmap, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().CreateBufferAttachedToBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageBufferStatics2> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageBufferStatics2>
    {
        int32_t __stdcall CreateFromBuffer(void* buffer, int32_t pixelFormat, uint32_t width, uint32_t height, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().CreateFromBuffer(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer), *reinterpret_cast<winrt::Microsoft::Graphics::Imaging::PixelFormat const*>(&pixelFormat), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromBufferWithStride(void* buffer, int32_t pixelFormat, uint32_t width, uint32_t height, uint32_t stride, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().CreateFromBufferWithStride(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer), *reinterpret_cast<winrt::Microsoft::Graphics::Imaging::PixelFormat const*>(&pixelFormat), width, height, stride));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageObjectExtractor> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageObjectExtractor>
    {
        int32_t __stdcall GetSoftwareBitmapObjectMask(void* hint, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().GetSoftwareBitmapObjectMask(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageObjectExtractorHint const*>(&hint)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetImageBufferObjectMask(void* hint, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().GetImageBufferObjectMask(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageObjectExtractorHint const*>(&hint)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHint> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHint>
    {
        int32_t __stdcall get_IncludeRects(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::RectInt32>>(this->shim().IncludeRects());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IncludePoints(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>>(this->shim().IncludePoints());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExcludePoints(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>>(this->shim().ExcludePoints());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHintFactory> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHintFactory>
    {
        int32_t __stdcall CreateInstance(void* includeRects, void* includePoints, void* excludePoints, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Imaging::ImageObjectExtractorHint>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Graphics::RectInt32> const*>(&includeRects), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Graphics::PointInt32> const*>(&includePoints), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Graphics::PointInt32> const*>(&excludePoints)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorStatics> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorStatics>
    {
        int32_t __stdcall CreateWithSoftwareBitmapAsync(void* softwareBitmap, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageObjectExtractor>>(this->shim().CreateWithSoftwareBitmapAsync(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithImageBufferAsync(void* imageBuffer, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageObjectExtractor>>(this->shim().CreateWithImageBufferAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageObjectRemover> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageObjectRemover>
    {
        int32_t __stdcall RemoveFromSoftwareBitmap(void* softwareBitmap, void* softwareBitmapMask, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().RemoveFromSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap), *reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmapMask)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemoveFromImageBuffer(void* imageBuffer, void* imageBufferMask, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().RemoveFromImageBuffer(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer), *reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBufferMask)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageObjectRemoverStatics> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageObjectRemoverStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageObjectRemover>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageScaler> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageScaler>
    {
        int32_t __stdcall ScaleSoftwareBitmap(void* softwareBitmap, int32_t width, int32_t height, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().ScaleSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ScaleImageBuffer(void* imageBuffer, int32_t width, int32_t height, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().ScaleImageBuffer(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxSupportedScaleFactor(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxSupportedScaleFactor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageScalerStatics> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageScalerStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageScaler>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Graphics::Imaging
{
    inline ImageBuffer::ImageBuffer(winrt::Windows::Storage::Streams::IBuffer const& buffer, winrt::Microsoft::Graphics::Imaging::PixelFormat const& pixelFormat, uint32_t width, uint32_t height) :
        ImageBuffer(impl::call_factory<ImageBuffer, IImageBufferFactory>([&](IImageBufferFactory const& f) { return f.CreateInstance(buffer, pixelFormat, width, height); }))
    {
    }
    inline auto ImageBuffer::CreateCopyFromBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap)
    {
        return impl::call_factory<ImageBuffer, IImageBufferStatics>([&](IImageBufferStatics const& f) { return f.CreateCopyFromBitmap(softwareBitmap); });
    }
    inline auto ImageBuffer::CreateBufferAttachedToBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap)
    {
        return impl::call_factory<ImageBuffer, IImageBufferStatics>([&](IImageBufferStatics const& f) { return f.CreateBufferAttachedToBitmap(softwareBitmap); });
    }
    inline auto ImageBuffer::CreateFromBuffer(winrt::Windows::Storage::Streams::IBuffer const& buffer, winrt::Microsoft::Graphics::Imaging::PixelFormat const& pixelFormat, uint32_t width, uint32_t height)
    {
        return impl::call_factory<ImageBuffer, IImageBufferStatics2>([&](IImageBufferStatics2 const& f) { return f.CreateFromBuffer(buffer, pixelFormat, width, height); });
    }
    inline auto ImageBuffer::CreateFromBufferWithStride(winrt::Windows::Storage::Streams::IBuffer const& buffer, winrt::Microsoft::Graphics::Imaging::PixelFormat const& pixelFormat, uint32_t width, uint32_t height, uint32_t stride)
    {
        return impl::call_factory<ImageBuffer, IImageBufferStatics2>([&](IImageBufferStatics2 const& f) { return f.CreateFromBufferWithStride(buffer, pixelFormat, width, height, stride); });
    }
    inline auto ImageObjectExtractor::CreateWithSoftwareBitmapAsync(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap)
    {
        return impl::call_factory<ImageObjectExtractor, IImageObjectExtractorStatics>([&](IImageObjectExtractorStatics const& f) { return f.CreateWithSoftwareBitmapAsync(softwareBitmap); });
    }
    inline auto ImageObjectExtractor::CreateWithImageBufferAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer)
    {
        return impl::call_factory<ImageObjectExtractor, IImageObjectExtractorStatics>([&](IImageObjectExtractorStatics const& f) { return f.CreateWithImageBufferAsync(imageBuffer); });
    }
    inline auto ImageObjectExtractor::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageObjectExtractorStatics const&), ImageObjectExtractor, IImageObjectExtractorStatics>([](IImageObjectExtractorStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageObjectExtractor::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageObjectExtractorStatics const&), ImageObjectExtractor, IImageObjectExtractorStatics>([](IImageObjectExtractorStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline ImageObjectExtractorHint::ImageObjectExtractorHint(param::vector<winrt::Windows::Graphics::RectInt32> const& includeRects, param::vector<winrt::Windows::Graphics::PointInt32> const& includePoints, param::vector<winrt::Windows::Graphics::PointInt32> const& excludePoints) :
        ImageObjectExtractorHint(impl::call_factory<ImageObjectExtractorHint, IImageObjectExtractorHintFactory>([&](IImageObjectExtractorHintFactory const& f) { return f.CreateInstance(includeRects, includePoints, excludePoints); }))
    {
    }
    inline auto ImageObjectRemover::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageObjectRemoverStatics const&), ImageObjectRemover, IImageObjectRemoverStatics>([](IImageObjectRemoverStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageObjectRemover::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageObjectRemoverStatics const&), ImageObjectRemover, IImageObjectRemoverStatics>([](IImageObjectRemoverStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto ImageObjectRemover::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageObjectRemover>(*)(IImageObjectRemoverStatics const&), ImageObjectRemover, IImageObjectRemoverStatics>([](IImageObjectRemoverStatics const& f) { return f.CreateAsync(); });
    }
    inline auto ImageScaler::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageScalerStatics const&), ImageScaler, IImageScalerStatics>([](IImageScalerStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageScaler::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageScalerStatics const&), ImageScaler, IImageScalerStatics>([](IImageScalerStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto ImageScaler::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Imaging::ImageScaler>(*)(IImageScalerStatics const&), ImageScaler, IImageScalerStatics>([](IImageScalerStatics const& f) { return f.CreateAsync(); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageBuffer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageBufferFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageObjectExtractor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHint> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorHintFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageObjectExtractorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageObjectRemover> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageObjectRemoverStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageScaler> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageScalerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::ImageBuffer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::ImageObjectExtractor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::ImageObjectExtractorHint> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::ImageObjectRemover> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::ImageScaler> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
