// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_PrivateCommon_H
#define WINRT_Microsoft_Windows_PrivateCommon_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Microsoft.Windows.PrivateCommon.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IAnchorInstance<D>::AnchorInstance(winrt::Windows::Foundation::IInspectable const& instance) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->AnchorInstance(*(void**)(&instance)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance>**)this;
            check_hresult(_winrt_abi_type->AnchorInstance(*(void**)(&instance)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IGetSessionHostProcessId<D>::GetSessionHostProcessId() const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSessionHostProcessId(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId>**)this;
            check_hresult(_winrt_abi_type->GetSessionHostProcessId(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferPrivate<D>::GetImageBufferView() const
    {
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferView result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetImageBufferView(put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>**)this;
            check_hresult(_winrt_abi_type->GetImageBufferView(put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferPrivate<D>::GetImageBufferViewData(uint32_t targetProcessId) const
    {
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetImageBufferViewData(targetProcessId, put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>**)this;
            check_hresult(_winrt_abi_type->GetImageBufferViewData(targetProcessId, put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferPrivate<D>::SyncBufferWithOutValue() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SyncBufferWithOutValue());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>**)this;
            check_hresult(_winrt_abi_type->SyncBufferWithOutValue());
        }
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferPrivate<D>::GetImageBufferResource(winrt::Windows::Foundation::IInspectable const& sessionAsInspectable) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetImageBufferResource(*(void**)(&sessionAsInspectable), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>**)this;
            check_hresult(_winrt_abi_type->GetImageBufferResource(*(void**)(&sessionAsInspectable), &result));
        }
        return winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::BufferData() const
    {
        winrt::Microsoft::Windows::PrivateCommon::ImageBufferData value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BufferData(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)this;
            check_hresult(_winrt_abi_type->get_BufferData(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::BufferData(winrt::Microsoft::Windows::PrivateCommon::ImageBufferData const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_BufferData(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)this;
            check_hresult(_winrt_abi_type->put_BufferData(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::Buffer() const
    {
        uint64_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Buffer(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)this;
            check_hresult(_winrt_abi_type->Buffer(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::Width() const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Width(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)this;
            check_hresult(_winrt_abi_type->Width(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::Height() const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Height(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)this;
            check_hresult(_winrt_abi_type->Height(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::RowStride() const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RowStride(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)this;
            check_hresult(_winrt_abi_type->RowStride(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::BytesPerPixel() const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->BytesPerPixel(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)this;
            check_hresult(_winrt_abi_type->BytesPerPixel(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::Capacity() const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Capacity(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)this;
            check_hresult(_winrt_abi_type->Capacity(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResource<D>::PixelFormat() const
    {
        winrt::Microsoft::Windows::PrivateCommon::PixelFormat result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->PixelFormat(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>**)this;
            check_hresult(_winrt_abi_type->PixelFormat(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResourceFactory<D>::CreateInstance(winrt::Microsoft::Windows::PrivateCommon::ImageBufferData const& bufferData) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(impl::bind_in(bufferData), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(impl::bind_in(bufferData), &value));
        }
        return winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IImageBufferResourceFactory<D>::CreateInstance2(uint32_t height, uint32_t width, winrt::Microsoft::Windows::PrivateCommon::PixelFormat const& pixelFormat, uint32_t rowStride, uint64_t targetProcessHandle, uint64_t sourceProcessHandle) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance2(height, width, static_cast<int32_t>(pixelFormat), rowStride, targetProcessHandle, sourceProcessHandle, &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance2(height, width, static_cast<int32_t>(pixelFormat), rowStride, targetProcessHandle, sourceProcessHandle, &value));
        }
        return winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IModelManager<D>::EnsureModelInitialized() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IModelManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureModelInitialized());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager>**)this;
            check_hresult(_winrt_abi_type->EnsureModelInitialized());
        }
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IModelManager<D>::GenerateCacheModel(param::hstring const& offlineDriverPath) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IModelManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateCacheModel(*(void**)(&offlineDriverPath)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager>**)this;
            check_hresult(_winrt_abi_type->GenerateCacheModel(*(void**)(&offlineDriverPath)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IModelManager2<D>::SetPackageFamilyName(param::hstring const& packageFamilyName) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IModelManager2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetPackageFamilyName(*(void**)(&packageFamilyName)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager2>**)this;
            check_hresult(_winrt_abi_type->SetPackageFamilyName(*(void**)(&packageFamilyName)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IModelManager3<D>::GenerateCacheModel() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IModelManager3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateCacheModel());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>**)this;
            check_hresult(_winrt_abi_type->GenerateCacheModel());
        }
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IModelManager3<D>::SetCorrelationVector(param::hstring const& correlationVector) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IModelManager3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetCorrelationVector(*(void**)(&correlationVector)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>**)this;
            check_hresult(_winrt_abi_type->SetCorrelationVector(*(void**)(&correlationVector)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_IModelManager3<D>::IsModelCacheReady() const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::IModelManager3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsModelCacheReady(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::IModelManager3>**)this;
            check_hresult(_winrt_abi_type->IsModelCacheReady(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_PrivateCommon_INotifyExpiredSessionHost<D>::NotifyExpiredSessionHost() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->NotifyExpiredSessionHost(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost>**)this;
            check_hresult(_winrt_abi_type->NotifyExpiredSessionHost(&operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance> : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance>
    {
        int32_t __stdcall AnchorInstance(void* instance) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AnchorInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&instance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId> : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId>
    {
        int32_t __stdcall GetSessionHostProcessId(uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().GetSessionHostProcessId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate> : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate>
    {
        int32_t __stdcall GetImageBufferView(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView* result) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView>(this->shim().GetImageBufferView());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetImageBufferViewData(uint32_t targetProcessId, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData* result) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData>(this->shim().GetImageBufferViewData(targetProcessId));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SyncBufferWithOutValue() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SyncBufferWithOutValue();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetImageBufferResource(void* sessionAsInspectable, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource>(this->shim().GetImageBufferResource(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&sessionAsInspectable)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource> : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource>
    {
        int32_t __stdcall get_BufferData(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferData* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::PrivateCommon::ImageBufferData>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::PrivateCommon::ImageBufferData>(this->shim().BufferData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BufferData(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferData value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BufferData(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferData const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Buffer(uint64_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint64_t>(this->shim().Buffer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Width(uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().Width());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Height(uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().Height());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RowStride(uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().RowStride());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall BytesPerPixel(uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().BytesPerPixel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Capacity(uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().Capacity());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall PixelFormat(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::PrivateCommon::PixelFormat>(this->shim().PixelFormat());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory> : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory>
    {
        int32_t __stdcall CreateInstance(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferData bufferData, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource>(this->shim().CreateInstance(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferData const*>(&bufferData)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstance2(uint32_t height, uint32_t width, int32_t pixelFormat, uint32_t rowStride, uint64_t targetProcessHandle, uint64_t sourceProcessHandle, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource>(this->shim().CreateInstance2(height, width, *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::PixelFormat const*>(&pixelFormat), rowStride, targetProcessHandle, sourceProcessHandle));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager> : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager>
    {
        int32_t __stdcall EnsureModelInitialized() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EnsureModelInitialized();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GenerateCacheModel(void* offlineDriverPath) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GenerateCacheModel(*reinterpret_cast<hstring const*>(&offlineDriverPath));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager2> : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager2>
    {
        int32_t __stdcall SetPackageFamilyName(void* packageFamilyName) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetPackageFamilyName(*reinterpret_cast<hstring const*>(&packageFamilyName));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager3> : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::IModelManager3>
    {
        int32_t __stdcall GenerateCacheModel() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GenerateCacheModel();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetCorrelationVector(void* correlationVector) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetCorrelationVector(*reinterpret_cast<hstring const*>(&correlationVector));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsModelCacheReady(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsModelCacheReady());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost> : produce_base<D, winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost>
    {
        int32_t __stdcall NotifyExpiredSessionHost(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().NotifyExpiredSessionHost());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::PrivateCommon
{
    inline ImageBufferResource::ImageBufferResource() :
        ImageBufferResource(impl::call_factory_cast<ImageBufferResource(*)(winrt::Windows::Foundation::IActivationFactory const&), ImageBufferResource>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ImageBufferResource>(); }))
    {
    }
    inline ImageBufferResource::ImageBufferResource(winrt::Microsoft::Windows::PrivateCommon::ImageBufferData const& bufferData) :
        ImageBufferResource(impl::call_factory<ImageBufferResource, IImageBufferResourceFactory>([&](IImageBufferResourceFactory const& f) { return f.CreateInstance(bufferData); }))
    {
    }
    inline ImageBufferResource::ImageBufferResource(uint32_t height, uint32_t width, winrt::Microsoft::Windows::PrivateCommon::PixelFormat const& pixelFormat, uint32_t rowStride, uint64_t targetProcessHandle, uint64_t sourceProcessHandle) :
        ImageBufferResource(impl::call_factory<ImageBufferResource, IImageBufferResourceFactory>([&](IImageBufferResourceFactory const& f) { return f.CreateInstance2(height, width, pixelFormat, rowStride, targetProcessHandle, sourceProcessHandle); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::IAnchorInstance> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::IGetSessionHostProcessId> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::IImageBufferPrivate> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::IImageBufferResourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::IModelManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::IModelManager2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::IModelManager3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::INotifyExpiredSessionHost> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
