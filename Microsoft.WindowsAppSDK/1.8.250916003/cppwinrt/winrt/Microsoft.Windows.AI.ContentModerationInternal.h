// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_AI_ContentModerationInternal_H
#define WINRT_Microsoft_Windows_AI_ContentModerationInternal_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Windows.AI.h"
#include "winrt/impl/Microsoft.Windows.PrivateCommon.2.h"
#include "winrt/impl/Microsoft.Windows.AI.ContentModerationInternal.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_AI_ContentModerationInternal_IImageContentModerationSession<D>::ValidateImage(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, uint32_t priority, uint32_t frequency) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ValidateImage(*(void**)(&inputImageBufferResource), priority, frequency, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession>**)this;
            check_hresult(_winrt_abi_type->ValidateImage(*(void**)(&inputImageBufferResource), priority, frequency, &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_ContentModerationInternal_IImageContentModerationSession<D>::AnalyzeImage(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, uint32_t priority, uint32_t frequency) const
    {
        winrt::Microsoft::Windows::AI::ContentModerationInternal::ImageContentAnalysisScores result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->AnalyzeImage(*(void**)(&inputImageBufferResource), priority, frequency, put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession>**)this;
            check_hresult(_winrt_abi_type->AnalyzeImage(*(void**)(&inputImageBufferResource), priority, frequency, put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_ContentModerationInternal_ITextBlockListSession<D>::IsTextBlocked(param::hstring const& query, param::hstring const& inputLanguage) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextBlockListSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextBlockListSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextBlockListSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsTextBlocked(*(void**)(&query), *(void**)(&inputLanguage), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextBlockListSession>**)this;
            check_hresult(_winrt_abi_type->IsTextBlocked(*(void**)(&query), *(void**)(&inputLanguage), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_ContentModerationInternal_ITextContentModerationSession<D>::AnalyzeText(param::hstring const& text, uint32_t priority, uint32_t frequency) const
    {
        winrt::Microsoft::Windows::AI::ContentModerationInternal::TextContentAnalysisScores result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextContentModerationSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextContentModerationSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextContentModerationSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->AnalyzeText(*(void**)(&text), priority, frequency, put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextContentModerationSession>**)this;
            check_hresult(_winrt_abi_type->AnalyzeText(*(void**)(&text), priority, frequency, put_abi(result)));
        }
        return result;
    }
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession> : produce_base<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession>
    {
        int32_t __stdcall ValidateImage(void* inputImageBufferResource, uint32_t priority, uint32_t frequency, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().ValidateImage(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AnalyzeImage(void* inputImageBufferResource, uint32_t priority, uint32_t frequency, struct struct_Microsoft_Windows_AI_ContentModerationInternal_ImageContentAnalysisScores* result) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::AI::ContentModerationInternal::ImageContentAnalysisScores>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::ContentModerationInternal::ImageContentAnalysisScores>(this->shim().AnalyzeImage(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextBlockListSession> : produce_base<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextBlockListSession>
    {
        int32_t __stdcall IsTextBlocked(void* query, void* inputLanguage, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsTextBlocked(*reinterpret_cast<hstring const*>(&query), *reinterpret_cast<hstring const*>(&inputLanguage)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextContentModerationSession> : produce_base<D, winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextContentModerationSession>
    {
        int32_t __stdcall AnalyzeText(void* text, uint32_t priority, uint32_t frequency, struct struct_Microsoft_Windows_AI_ContentModerationInternal_TextContentAnalysisScores* result) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::AI::ContentModerationInternal::TextContentAnalysisScores>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::ContentModerationInternal::TextContentAnalysisScores>(this->shim().AnalyzeText(*reinterpret_cast<hstring const*>(&text), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::AI::ContentModerationInternal
{
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::AI::ContentModerationInternal::IImageContentModerationSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextBlockListSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::ContentModerationInternal::ITextContentModerationSession> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
