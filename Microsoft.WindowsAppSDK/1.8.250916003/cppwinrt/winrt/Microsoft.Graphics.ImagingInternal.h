// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Graphics_ImagingInternal_H
#define WINRT_Microsoft_Graphics_ImagingInternal_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Windows.PrivateCommon.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Microsoft.Graphics.ImagingInternal.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IDepthMapCreatorSession<D>::CreateAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& inputBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& inputBufferViewData, winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& outputBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& outputBufferViewData) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(impl::bind_in(inputBufferView), impl::bind_in(inputBufferViewData), impl::bind_in(outputBufferView), impl::bind_in(outputBufferViewData), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(impl::bind_in(inputBufferView), impl::bind_in(inputBufferViewData), impl::bind_in(outputBufferView), impl::bind_in(outputBufferViewData), &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IDepthMapCreatorSession2<D>::Create(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& outputImageBufferResource, uint32_t priority, uint32_t frequency) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&inputImageBufferResource), *(void**)(&outputImageBufferResource), priority, frequency));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&inputImageBufferResource), *(void**)(&outputImageBufferResource), priority, frequency));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IImageObjectExtractorSession<D>::InitializeWithImageBuffer(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, uint32_t priority, uint32_t frequency, array_view<float> encoding) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->InitializeWithImageBuffer(*(void**)(&inputImageBufferResource), priority, frequency, encoding.size(), put_abi(encoding)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>**)this;
            check_hresult(_winrt_abi_type->InitializeWithImageBuffer(*(void**)(&inputImageBufferResource), priority, frequency, encoding.size(), put_abi(encoding)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IImageObjectExtractorSession<D>::GetBackground(array_view<float const> encoding, winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& outputImageBufferResource, array_view<winrt::Windows::Graphics::RectInt32 const> rects, array_view<winrt::Windows::Graphics::PointInt32 const> inclusionPoints, array_view<winrt::Windows::Graphics::PointInt32 const> exclusionPoints, uint32_t priority, uint32_t frequency) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetBackground(encoding.size(), get_abi(encoding), *(void**)(&outputImageBufferResource), rects.size(), get_abi(rects), inclusionPoints.size(), get_abi(inclusionPoints), exclusionPoints.size(), get_abi(exclusionPoints), priority, frequency));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>**)this;
            check_hresult(_winrt_abi_type->GetBackground(encoding.size(), get_abi(encoding), *(void**)(&outputImageBufferResource), rects.size(), get_abi(rects), inclusionPoints.size(), get_abi(inclusionPoints), exclusionPoints.size(), get_abi(exclusionPoints), priority, frequency));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IImageObjectExtractorSession<D>::GetModelProperties() const
    {
        winrt::Microsoft::Graphics::ImagingInternal::ModelProperties result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetModelProperties(put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>**)this;
            check_hresult(_winrt_abi_type->GetModelProperties(put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IImageScalerSession<D>::ScaleImage(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& outputImageBufferResource, int32_t width, int32_t height, uint32_t priority, uint32_t frequency) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ScaleImage(*(void**)(&inputImageBufferResource), *(void**)(&outputImageBufferResource), width, height, priority, frequency));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession>**)this;
            check_hresult(_winrt_abi_type->ScaleImage(*(void**)(&inputImageBufferResource), *(void**)(&outputImageBufferResource), width, height, priority, frequency));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IImageScalerSession<D>::MaxSupportedScaleFactor() const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MaxSupportedScaleFactor(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession>**)this;
            check_hresult(_winrt_abi_type->MaxSupportedScaleFactor(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IImageSegmenterSession<D>::RemoveBackground(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& outputImageBufferResource) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RemoveBackground(*(void**)(&inputImageBufferResource), *(void**)(&outputImageBufferResource)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession>**)this;
            check_hresult(_winrt_abi_type->RemoveBackground(*(void**)(&inputImageBufferResource), *(void**)(&outputImageBufferResource)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IParallaxCreatorSession<D>::CreateParallaxImagesAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& inputView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& inputViewData, param::async_vector_view<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView> const& outputViews, param::async_vector_view<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData> const& outputViewData, winrt::Microsoft::Graphics::ImagingInternal::ParallaxImageOptions const& options) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateParallaxImagesAsync(impl::bind_in(inputView), impl::bind_in(inputViewData), *(void**)(&outputViews), *(void**)(&outputViewData), impl::bind_in(options), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession>**)this;
            check_hresult(_winrt_abi_type->CreateParallaxImagesAsync(impl::bind_in(inputView), impl::bind_in(inputViewData), *(void**)(&outputViews), *(void**)(&outputViewData), impl::bind_in(options), &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IParallaxCreatorSession2<D>::CreateParallaxImagesAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& inputView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& inputViewData, param::async_vector_view<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView> const& outputViews, param::async_vector_view<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData> const& outputViewData, winrt::Microsoft::Graphics::ImagingInternal::ParallaxImageOptions const& options, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateParallaxImagesAsync(impl::bind_in(inputView), impl::bind_in(inputViewData), *(void**)(&outputViews), *(void**)(&outputViewData), impl::bind_in(options), priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2>**)this;
            check_hresult(_winrt_abi_type->CreateParallaxImagesAsync(impl::bind_in(inputView), impl::bind_in(inputViewData), *(void**)(&outputViews), *(void**)(&outputViewData), impl::bind_in(options), priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_IParallaxCreatorSession3<D>::CreateParallaxImages(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, array_view<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const> outputImageBufferResources, winrt::Microsoft::Graphics::ImagingInternal::ParallaxImageOptions const& options, uint32_t priority, uint32_t frequency) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateParallaxImages(*(void**)(&inputImageBufferResource), outputImageBufferResources.size(), get_abi(outputImageBufferResources), impl::bind_in(options), priority, frequency));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3>**)this;
            check_hresult(_winrt_abi_type->CreateParallaxImages(*(void**)(&inputImageBufferResource), outputImageBufferResources.size(), get_abi(outputImageBufferResources), impl::bind_in(options), priority, frequency));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_ITrimapImageSegmenterSession<D>::RemoveBackgroundAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& inputImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& inputImageBufferViewData, winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& outputImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& outputImageBufferViewData, winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& fgMaskImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& fgMaskImageBufferViewData, winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& bgMaskImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& bgMaskImageBufferViewData) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RemoveBackgroundAsync(impl::bind_in(inputImageBufferView), impl::bind_in(inputImageBufferViewData), impl::bind_in(outputImageBufferView), impl::bind_in(outputImageBufferViewData), impl::bind_in(fgMaskImageBufferView), impl::bind_in(fgMaskImageBufferViewData), impl::bind_in(bgMaskImageBufferView), impl::bind_in(bgMaskImageBufferViewData), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession>**)this;
            check_hresult(_winrt_abi_type->RemoveBackgroundAsync(impl::bind_in(inputImageBufferView), impl::bind_in(inputImageBufferViewData), impl::bind_in(outputImageBufferView), impl::bind_in(outputImageBufferViewData), impl::bind_in(fgMaskImageBufferView), impl::bind_in(fgMaskImageBufferViewData), impl::bind_in(bgMaskImageBufferView), impl::bind_in(bgMaskImageBufferViewData), &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_ITrimapImageSegmenterSession2<D>::RemoveBackgroundAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& inputImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& inputImageBufferViewData, winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& outputImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& outputImageBufferViewData, winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& fgMaskImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& fgMaskImageBufferViewData, winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& bgMaskImageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& bgMaskImageBufferViewData, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RemoveBackgroundAsync(impl::bind_in(inputImageBufferView), impl::bind_in(inputImageBufferViewData), impl::bind_in(outputImageBufferView), impl::bind_in(outputImageBufferViewData), impl::bind_in(fgMaskImageBufferView), impl::bind_in(fgMaskImageBufferViewData), impl::bind_in(bgMaskImageBufferView), impl::bind_in(bgMaskImageBufferViewData), priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession2>**)this;
            check_hresult(_winrt_abi_type->RemoveBackgroundAsync(impl::bind_in(inputImageBufferView), impl::bind_in(inputImageBufferViewData), impl::bind_in(outputImageBufferView), impl::bind_in(outputImageBufferViewData), impl::bind_in(fgMaskImageBufferView), impl::bind_in(fgMaskImageBufferViewData), impl::bind_in(bgMaskImageBufferView), impl::bind_in(bgMaskImageBufferViewData), priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_ImagingInternal_ITrimapImageSegmenterSession3<D>::RemoveBackground(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& outputImageBufferResource, winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& fgMaskImageBufferResource, winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& bgMaskImageBufferResource, uint32_t priority, uint32_t frequency) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RemoveBackground(*(void**)(&inputImageBufferResource), *(void**)(&outputImageBufferResource), *(void**)(&fgMaskImageBufferResource), *(void**)(&bgMaskImageBufferResource), priority, frequency));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession3>**)this;
            check_hresult(_winrt_abi_type->RemoveBackground(*(void**)(&inputImageBufferResource), *(void**)(&outputImageBufferResource), *(void**)(&fgMaskImageBufferResource), *(void**)(&bgMaskImageBufferResource), priority, frequency));
        }
    }
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession>
    {
        int32_t __stdcall CreateAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView inputBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData inputBufferViewData, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView outputBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData outputBufferViewData, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&inputBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&inputBufferViewData), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&outputBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&outputBufferViewData)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2>
    {
        int32_t __stdcall Create(void* inputImageBufferResource, void* outputImageBufferResource, uint32_t priority, uint32_t frequency) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Create(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&outputImageBufferResource), priority, frequency);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession>
    {
        int32_t __stdcall InitializeWithImageBuffer(void* inputImageBufferResource, uint32_t priority, uint32_t frequency, uint32_t __encodingSize, float* encoding) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InitializeWithImageBuffer(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), priority, frequency, array_view<float>(reinterpret_cast<float*>(encoding), reinterpret_cast<float*>(encoding) + __encodingSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetBackground(uint32_t __encodingSize, float* encoding, void* outputImageBufferResource, uint32_t __rectsSize, struct struct_Windows_Graphics_RectInt32* rects, uint32_t __inclusionPointsSize, struct struct_Windows_Graphics_PointInt32* inclusionPoints, uint32_t __exclusionPointsSize, struct struct_Windows_Graphics_PointInt32* exclusionPoints, uint32_t priority, uint32_t frequency) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GetBackground(array_view<float const>(reinterpret_cast<float const *>(encoding), reinterpret_cast<float const *>(encoding) + __encodingSize), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&outputImageBufferResource), array_view<winrt::Windows::Graphics::RectInt32 const>(reinterpret_cast<winrt::Windows::Graphics::RectInt32 const *>(rects), reinterpret_cast<winrt::Windows::Graphics::RectInt32 const *>(rects) + __rectsSize), array_view<winrt::Windows::Graphics::PointInt32 const>(reinterpret_cast<winrt::Windows::Graphics::PointInt32 const *>(inclusionPoints), reinterpret_cast<winrt::Windows::Graphics::PointInt32 const *>(inclusionPoints) + __inclusionPointsSize), array_view<winrt::Windows::Graphics::PointInt32 const>(reinterpret_cast<winrt::Windows::Graphics::PointInt32 const *>(exclusionPoints), reinterpret_cast<winrt::Windows::Graphics::PointInt32 const *>(exclusionPoints) + __exclusionPointsSize), priority, frequency);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetModelProperties(struct struct_Microsoft_Graphics_ImagingInternal_ModelProperties* result) noexcept final try
        {
            zero_abi<winrt::Microsoft::Graphics::ImagingInternal::ModelProperties>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::ImagingInternal::ModelProperties>(this->shim().GetModelProperties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession>
    {
        int32_t __stdcall ScaleImage(void* inputImageBufferResource, void* outputImageBufferResource, int32_t width, int32_t height, uint32_t priority, uint32_t frequency) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ScaleImage(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&outputImageBufferResource), width, height, priority, frequency);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MaxSupportedScaleFactor(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().MaxSupportedScaleFactor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession>
    {
        int32_t __stdcall RemoveBackground(void* inputImageBufferResource, void* outputImageBufferResource) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RemoveBackground(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&outputImageBufferResource));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession>
    {
        int32_t __stdcall CreateParallaxImagesAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView inputView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData inputViewData, void* outputViews, void* outputViewData, struct struct_Microsoft_Graphics_ImagingInternal_ParallaxImageOptions options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateParallaxImagesAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&inputView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&inputViewData), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView> const*>(&outputViews), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData> const*>(&outputViewData), *reinterpret_cast<winrt::Microsoft::Graphics::ImagingInternal::ParallaxImageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2>
    {
        int32_t __stdcall CreateParallaxImagesAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView inputView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData inputViewData, void* outputViews, void* outputViewData, struct struct_Microsoft_Graphics_ImagingInternal_ParallaxImageOptions options, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateParallaxImagesAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&inputView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&inputViewData), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView> const*>(&outputViews), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData> const*>(&outputViewData), *reinterpret_cast<winrt::Microsoft::Graphics::ImagingInternal::ParallaxImageOptions const*>(&options), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3>
    {
        int32_t __stdcall CreateParallaxImages(void* inputImageBufferResource, uint32_t __outputImageBufferResourcesSize, void** outputImageBufferResources, struct struct_Microsoft_Graphics_ImagingInternal_ParallaxImageOptions options, uint32_t priority, uint32_t frequency) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CreateParallaxImages(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), array_view<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const>(reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const *>(outputImageBufferResources), reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const *>(outputImageBufferResources) + __outputImageBufferResourcesSize), *reinterpret_cast<winrt::Microsoft::Graphics::ImagingInternal::ParallaxImageOptions const*>(&options), priority, frequency);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession>
    {
        int32_t __stdcall RemoveBackgroundAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView inputImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData inputImageBufferViewData, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView outputImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData outputImageBufferViewData, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView fgMaskImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData fgMaskImageBufferViewData, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView bgMaskImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData bgMaskImageBufferViewData, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().RemoveBackgroundAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&inputImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&inputImageBufferViewData), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&outputImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&outputImageBufferViewData), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&fgMaskImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&fgMaskImageBufferViewData), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&bgMaskImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&bgMaskImageBufferViewData)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession2> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession2>
    {
        int32_t __stdcall RemoveBackgroundAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView inputImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData inputImageBufferViewData, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView outputImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData outputImageBufferViewData, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView fgMaskImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData fgMaskImageBufferViewData, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView bgMaskImageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData bgMaskImageBufferViewData, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().RemoveBackgroundAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&inputImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&inputImageBufferViewData), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&outputImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&outputImageBufferViewData), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&fgMaskImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&fgMaskImageBufferViewData), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&bgMaskImageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&bgMaskImageBufferViewData), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession3> : produce_base<D, winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession3>
    {
        int32_t __stdcall RemoveBackground(void* inputImageBufferResource, void* outputImageBufferResource, void* fgMaskImageBufferResource, void* bgMaskImageBufferResource, uint32_t priority, uint32_t frequency) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RemoveBackground(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&outputImageBufferResource), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&fgMaskImageBufferResource), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&bgMaskImageBufferResource), priority, frequency);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::Microsoft::Graphics::ImagingInternal
{
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::IDepthMapCreatorSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::IImageObjectExtractorSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::IImageScalerSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::IImageSegmenterSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::IParallaxCreatorSession3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::ImagingInternal::ITrimapImageSegmenterSession3> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
