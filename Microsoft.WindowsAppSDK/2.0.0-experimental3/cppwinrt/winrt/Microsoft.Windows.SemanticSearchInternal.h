// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_SemanticSearchInternal_H
#define WINRT_Microsoft_Windows_SemanticSearchInternal_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Windows.PrivateCommon.2.h"
#include "winrt/impl/Microsoft.Windows.SemanticSearch.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Microsoft.Windows.SemanticSearchInternal.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchImageEmbeddingsSession<D>::CreateAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& imageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& imageBufferViewData) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(impl::bind_in(imageBufferView), impl::bind_in(imageBufferViewData), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(impl::bind_in(imageBufferView), impl::bind_in(imageBufferViewData), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchImageEmbeddingsSession<D>::OutputLength() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OutputLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>**)this;
            check_hresult(_winrt_abi_type->get_OutputLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchImageEmbeddingsSession<D>::VectorSpaceId() const
    {
        winrt::guid value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VectorSpaceId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>**)this;
            check_hresult(_winrt_abi_type->get_VectorSpaceId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchImageEmbeddingsSession<D>::ModelVersion() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>**)this;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchImageEmbeddingsSession2<D>::CreateAsync(winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const& imageBufferView, winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const& imageBufferViewData, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(impl::bind_in(imageBufferView), impl::bind_in(imageBufferViewData), priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession2>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(impl::bind_in(imageBufferView), impl::bind_in(imageBufferViewData), priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchImageEmbeddingsSession3<D>::Create(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& inputImageBufferResource, uint32_t priority, uint32_t frequency) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&inputImageBufferResource), priority, frequency, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession3>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&inputImageBufferResource), priority, frequency, &result));
        }
        return winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchImageEmbeddingsSession4<D>::GetIntermediateOutputLength() const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetIntermediateOutputLength(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4>**)this;
            check_hresult(_winrt_abi_type->GetIntermediateOutputLength(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchImageEmbeddingsSession4<D>::ProcessIntermediate(winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const& image, uint32_t outputLength, uint32_t priority) const
    {
        uint32_t result_impl_size{};
        float* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ProcessIntermediate(*(void**)(&image), outputLength, priority, &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4>**)this;
            check_hresult(_winrt_abi_type->ProcessIntermediate(*(void**)(&image), outputLength, priority, &result_impl_size, &result));
        }
        return com_array<float>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchTextEmbeddingsSession<D>::CreateAsync(param::hstring const& text) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(*(void**)(&text), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(*(void**)(&text), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchTextEmbeddingsSession<D>::OutputLength() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OutputLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>**)this;
            check_hresult(_winrt_abi_type->get_OutputLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchTextEmbeddingsSession<D>::VectorSpaceId() const
    {
        winrt::guid value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VectorSpaceId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>**)this;
            check_hresult(_winrt_abi_type->get_VectorSpaceId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchTextEmbeddingsSession<D>::ModelVersion() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>**)this;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchTextEmbeddingsSession2<D>::CreateAsync(param::hstring const& text, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(*(void**)(&text), priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession2>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(*(void**)(&text), priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchTextEmbeddingsSession3<D>::Create(param::hstring const& text, uint32_t priority, uint32_t frequency) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&text), priority, frequency, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession3>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&text), priority, frequency, &result));
        }
        return winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IImageSearchTextEmbeddingsSession4<D>::CreateFromTokens(array_view<int64_t const> tokens, uint32_t priority, uint32_t frequency) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromTokens(tokens.size(), get_abi(tokens), priority, frequency, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession4>**)this;
            check_hresult(_winrt_abi_type->CreateFromTokens(tokens.size(), get_abi(tokens), priority, frequency, &result));
        }
        return winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryAllowList<D>::Initialize(param::map_view<hstring, winrt::Windows::Foundation::Collections::IVectorView<hstring>> const& allowedTermsByLocale) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Initialize(*(void**)(&allowedTermsByLocale)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>**)this;
            check_hresult(_winrt_abi_type->Initialize(*(void**)(&allowedTermsByLocale)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryAllowList<D>::Initialize(param::hstring const& locale, array_view<hstring const> allowedTerms) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Initialize2(*(void**)(&locale), allowedTerms.size(), get_abi(allowedTerms)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>**)this;
            check_hresult(_winrt_abi_type->Initialize2(*(void**)(&locale), allowedTerms.size(), get_abi(allowedTerms)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryAllowList<D>::IsTermAllowed(param::hstring const& term, param::hstring const& locale) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsTermAllowed(*(void**)(&term), *(void**)(&locale), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>**)this;
            check_hresult(_winrt_abi_type->IsTermAllowed(*(void**)(&term), *(void**)(&locale), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryAllowList<D>::GetSupportedLocales() const
    {
        uint32_t result_impl_size{};
        void** result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSupportedLocales(&result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>**)this;
            check_hresult(_winrt_abi_type->GetSupportedLocales(&result_impl_size, &result));
        }
        return com_array<hstring>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryBlockListMatch<D>::Reason() const
    {
        winrt::Microsoft::Windows::SemanticSearchInternal::QueryBlockListMatchReason value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch>**)this;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryBlockListMatch2<D>::Context() const
    {
        winrt::Microsoft::Windows::SemanticSearchInternal::HarmfulAssocationContext value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Context(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch2>**)this;
            check_hresult(_winrt_abi_type->get_Context(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryBlockListSession<D>::IsQueryBlocked(param::hstring const& query, param::hstring const& inputLanguage) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsQueryBlocked(*(void**)(&query), *(void**)(&inputLanguage), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession>**)this;
            check_hresult(_winrt_abi_type->IsQueryBlocked(*(void**)(&query), *(void**)(&inputLanguage), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryBlockListSession<D>::Version() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Version(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession>**)this;
            check_hresult(_winrt_abi_type->get_Version(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryBlockListSession2<D>::IsQueryBlocked(param::hstring const& query, param::hstring const& inputLanguage, param::hstring const& correlationId) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsQueryBlocked(*(void**)(&query), *(void**)(&inputLanguage), *(void**)(&correlationId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession2>**)this;
            check_hresult(_winrt_abi_type->IsQueryBlocked(*(void**)(&query), *(void**)(&inputLanguage), *(void**)(&correlationId), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryBlockListSession3<D>::FindMatches(param::hstring const& query, param::hstring const& inputLanguage, param::hstring const& correlationId) const
    {
        uint32_t result_impl_size{};
        void** result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FindMatches(*(void**)(&query), *(void**)(&inputLanguage), *(void**)(&correlationId), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession3>**)this;
            check_hresult(_winrt_abi_type->FindMatches(*(void**)(&query), *(void**)(&inputLanguage), *(void**)(&correlationId), &result_impl_size, &result));
        }
        return com_array<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryBlockListSession4<D>::CreateAllowList() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAllowList(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>**)this;
            check_hresult(_winrt_abi_type->CreateAllowList(&result));
        }
        return winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryBlockListSession4<D>::IsQueryBlocked(param::hstring const& query, param::hstring const& inputLanguage, param::hstring const& correlationId, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList const& allowList) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsQueryBlocked(*(void**)(&query), *(void**)(&inputLanguage), *(void**)(&correlationId), *(void**)(&allowList), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>**)this;
            check_hresult(_winrt_abi_type->IsQueryBlocked(*(void**)(&query), *(void**)(&inputLanguage), *(void**)(&correlationId), *(void**)(&allowList), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryBlockListSession4<D>::FindMatches(param::hstring const& query, param::hstring const& inputLanguage, param::hstring const& correlationId, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList const& allowList) const
    {
        uint32_t result_impl_size{};
        void** result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FindMatches(*(void**)(&query), *(void**)(&inputLanguage), *(void**)(&correlationId), *(void**)(&allowList), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>**)this;
            check_hresult(_winrt_abi_type->FindMatches(*(void**)(&query), *(void**)(&inputLanguage), *(void**)(&correlationId), *(void**)(&allowList), &result_impl_size, &result));
        }
        return com_array<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryProcessorSession<D>::GetQueryParametersAsync(param::hstring const& naturalLanguageQuery) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetQueryParametersAsync(*(void**)(&naturalLanguageQuery), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession>**)this;
            check_hresult(_winrt_abi_type->GetQueryParametersAsync(*(void**)(&naturalLanguageQuery), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearchInternal::QueryParametersInternal>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryProcessorSession2<D>::GetQueryParametersAsync(param::hstring const& naturalLanguageQuery, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetQueryParametersAsync(*(void**)(&naturalLanguageQuery), priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession2>**)this;
            check_hresult(_winrt_abi_type->GetQueryParametersAsync(*(void**)(&naturalLanguageQuery), priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearchInternal::QueryParametersInternal>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_IQueryProcessorSession3<D>::GetQueryParameters(param::hstring const& naturalLanguageQuery, uint32_t priority, uint32_t frequency) const
    {
        winrt::Microsoft::Windows::SemanticSearchInternal::QueryParametersInternal result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetQueryParameters(*(void**)(&naturalLanguageQuery), priority, frequency, put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession3>**)this;
            check_hresult(_winrt_abi_type->GetQueryParameters(*(void**)(&naturalLanguageQuery), priority, frequency, put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession<D>::CreateAsync(param::hstring const& text, array_view<float> values) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(*(void**)(&text), values.size(), put_abi(values), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(*(void**)(&text), values.size(), put_abi(values), &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession<D>::CreateFromTokensAsync(array_view<int64_t const> tokens, array_view<float> values) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromTokensAsync(tokens.size(), get_abi(tokens), values.size(), put_abi(values), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)this;
            check_hresult(_winrt_abi_type->CreateFromTokensAsync(tokens.size(), get_abi(tokens), values.size(), put_abi(values), &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession<D>::Create(param::hstring const& text, array_view<float> values) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&text), values.size(), put_abi(values)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&text), values.size(), put_abi(values)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession<D>::CreateFromTokens(array_view<int64_t const> tokens, array_view<float> values) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromTokens(tokens.size(), get_abi(tokens), values.size(), put_abi(values)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)this;
            check_hresult(_winrt_abi_type->CreateFromTokens(tokens.size(), get_abi(tokens), values.size(), put_abi(values)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession<D>::OutputLength() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OutputLength(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)this;
            check_hresult(_winrt_abi_type->get_OutputLength(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession<D>::VectorSpaceId() const
    {
        winrt::guid value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VectorSpaceId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)this;
            check_hresult(_winrt_abi_type->get_VectorSpaceId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession<D>::ModelVersion() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>**)this;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession2<D>::CreateAsync(param::hstring const& text, array_view<float> values, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(*(void**)(&text), values.size(), put_abi(values), priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(*(void**)(&text), values.size(), put_abi(values), priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession2<D>::CreateFromTokensAsync(array_view<int64_t const> tokens, array_view<float> values, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromTokensAsync(tokens.size(), get_abi(tokens), values.size(), put_abi(values), priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>**)this;
            check_hresult(_winrt_abi_type->CreateFromTokensAsync(tokens.size(), get_abi(tokens), values.size(), put_abi(values), priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession2<D>::Create(param::hstring const& text, array_view<float> values, uint32_t priority, uint32_t frequency) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&text), values.size(), put_abi(values), priority, frequency));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&text), values.size(), put_abi(values), priority, frequency));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ISemanticTextSession2<D>::CreateFromTokens(array_view<int64_t const> tokens, array_view<float> values, uint32_t priority, uint32_t frequency) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromTokens(tokens.size(), get_abi(tokens), values.size(), put_abi(values), priority, frequency));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>**)this;
            check_hresult(_winrt_abi_type->CreateFromTokens(tokens.size(), get_abi(tokens), values.size(), put_abi(values), priority, frequency));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITokenizerSession<D>::ShouldTokenize(uint64_t charCount, uint64_t maxTokenCount) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ShouldTokenize(charCount, maxTokenCount, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>**)this;
            check_hresult(_winrt_abi_type->ShouldTokenize(charCount, maxTokenCount, &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITokenizerSession<D>::Tokenize(uint64_t maxTokenCount, param::hstring const& text, array_view<int64_t> tokens, uint64_t& tokensUsed, array_view<uint64_t> indices, uint64_t& indicesUsed) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Tokenize(maxTokenCount, *(void**)(&text), tokens.size(), put_abi(tokens), &tokensUsed, indices.size(), put_abi(indices), &indicesUsed));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>**)this;
            check_hresult(_winrt_abi_type->Tokenize(maxTokenCount, *(void**)(&text), tokens.size(), put_abi(tokens), &tokensUsed, indices.size(), put_abi(indices), &indicesUsed));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITokenizerSession<D>::ModelVersion() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>**)this;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITokenizerSession2<D>::Tokenize(uint64_t maxTokenCount, param::hstring const& text, array_view<int64_t> tokens, uint64_t& tokensUsed, array_view<uint64_t> indices, uint64_t& indicesUsed, uint32_t priority, uint32_t frequency) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Tokenize(maxTokenCount, *(void**)(&text), tokens.size(), put_abi(tokens), &tokensUsed, indices.size(), put_abi(indices), &indicesUsed, priority, frequency));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession2>**)this;
            check_hresult(_winrt_abi_type->Tokenize(maxTokenCount, *(void**)(&text), tokens.size(), put_abi(tokens), &tokensUsed, indices.size(), put_abi(indices), &indicesUsed, priority, frequency));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITopicProcessorSession<D>::GetTopicsAsync(param::hstring const& text, uint32_t maxCount) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetTopicsAsync(*(void**)(&text), maxCount, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>**)this;
            check_hresult(_winrt_abi_type->GetTopicsAsync(*(void**)(&text), maxCount, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::SemanticSearchInternal::TopicInternal>>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITopicProcessorSession<D>::GetTopics(param::hstring const& text, uint32_t maxCount) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetTopics(*(void**)(&text), maxCount, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>**)this;
            check_hresult(_winrt_abi_type->GetTopics(*(void**)(&text), maxCount, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::SemanticSearchInternal::TopicInternal>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITopicProcessorSession<D>::GetDisplayName(param::hstring const& className, param::hstring const& languageTag) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDisplayName(*(void**)(&className), *(void**)(&languageTag), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>**)this;
            check_hresult(_winrt_abi_type->GetDisplayName(*(void**)(&className), *(void**)(&languageTag), &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITopicProcessorSession<D>::ModelVersion() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>**)this;
            check_hresult(_winrt_abi_type->get_ModelVersion(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITopicProcessorSession2<D>::GetTopicsAsync(param::hstring const& text, uint32_t maxCount, uint32_t priority, uint32_t frequency) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetTopicsAsync(*(void**)(&text), maxCount, priority, frequency, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2>**)this;
            check_hresult(_winrt_abi_type->GetTopicsAsync(*(void**)(&text), maxCount, priority, frequency, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::SemanticSearchInternal::TopicInternal>>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_SemanticSearchInternal_ITopicProcessorSession2<D>::GetTopics(param::hstring const& text, uint32_t maxCount, uint32_t priority, uint32_t frequency) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetTopics(*(void**)(&text), maxCount, priority, frequency, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2>**)this;
            check_hresult(_winrt_abi_type->GetTopics(*(void**)(&text), maxCount, priority, frequency, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::SemanticSearchInternal::TopicInternal>{ result, take_ownership_from_abi };
    }
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession>
    {
        int32_t __stdcall CreateAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView imageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData imageBufferViewData, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>>(this->shim().CreateAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&imageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&imageBufferViewData)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OutputLength(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().OutputLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VectorSpaceId(winrt::guid* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::guid>(this->shim().VectorSpaceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ModelVersion(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ModelVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession2> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession2>
    {
        int32_t __stdcall CreateAsync(struct struct_Microsoft_Windows_PrivateCommon_ImageBufferView imageBufferView, struct struct_Microsoft_Windows_PrivateCommon_ImageBufferViewData imageBufferViewData, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>>(this->shim().CreateAsync(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferView const*>(&imageBufferView), *reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferViewData const*>(&imageBufferViewData), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession3> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession3>
    {
        int32_t __stdcall Create(void* inputImageBufferResource, uint32_t priority, uint32_t frequency, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&inputImageBufferResource), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4>
    {
        int32_t __stdcall GetIntermediateOutputLength(uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().GetIntermediateOutputLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProcessIntermediate(void* image, uint32_t outputLength, uint32_t priority, uint32_t* __resultSize, float** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().ProcessIntermediate(*reinterpret_cast<winrt::Microsoft::Windows::PrivateCommon::ImageBufferResource const*>(&image), outputLength, priority));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession>
    {
        int32_t __stdcall CreateAsync(void* text, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>>(this->shim().CreateAsync(*reinterpret_cast<hstring const*>(&text)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OutputLength(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().OutputLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VectorSpaceId(winrt::guid* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::guid>(this->shim().VectorSpaceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ModelVersion(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ModelVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession2> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession2>
    {
        int32_t __stdcall CreateAsync(void* text, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>>(this->shim().CreateAsync(*reinterpret_cast<hstring const*>(&text), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession3> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession3>
    {
        int32_t __stdcall Create(void* text, uint32_t priority, uint32_t frequency, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>(this->shim().Create(*reinterpret_cast<hstring const*>(&text), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession4> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession4>
    {
        int32_t __stdcall CreateFromTokens(uint32_t __tokensSize, int64_t* tokens, uint32_t priority, uint32_t frequency, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::SemanticSearch::EmbeddingVector>(this->shim().CreateFromTokens(array_view<int64_t const>(reinterpret_cast<int64_t const *>(tokens), reinterpret_cast<int64_t const *>(tokens) + __tokensSize), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>
    {
        int32_t __stdcall Initialize(void* allowedTermsByLocale) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Initialize(*reinterpret_cast<winrt::Windows::Foundation::Collections::IMapView<hstring, winrt::Windows::Foundation::Collections::IVectorView<hstring>> const*>(&allowedTermsByLocale));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Initialize2(void* locale, uint32_t __allowedTermsSize, void** allowedTerms) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Initialize(*reinterpret_cast<hstring const*>(&locale), array_view<hstring const>(reinterpret_cast<hstring const *>(allowedTerms), reinterpret_cast<hstring const *>(allowedTerms) + __allowedTermsSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsTermAllowed(void* term, void* locale, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsTermAllowed(*reinterpret_cast<hstring const*>(&term), *reinterpret_cast<hstring const*>(&locale)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSupportedLocales(uint32_t* __resultSize, void*** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetSupportedLocales());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch>
    {
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::SemanticSearchInternal::QueryBlockListMatchReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch2> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch2>
    {
        int32_t __stdcall get_Context(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::SemanticSearchInternal::HarmfulAssocationContext>(this->shim().Context());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession>
    {
        int32_t __stdcall IsQueryBlocked(void* query, void* inputLanguage, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsQueryBlocked(*reinterpret_cast<hstring const*>(&query), *reinterpret_cast<hstring const*>(&inputLanguage)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Version(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Version());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession2> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession2>
    {
        int32_t __stdcall IsQueryBlocked(void* query, void* inputLanguage, void* correlationId, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsQueryBlocked(*reinterpret_cast<hstring const*>(&query), *reinterpret_cast<hstring const*>(&inputLanguage), *reinterpret_cast<hstring const*>(&correlationId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession3> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession3>
    {
        int32_t __stdcall FindMatches(void* query, void* inputLanguage, void* correlationId, uint32_t* __resultSize, void*** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().FindMatches(*reinterpret_cast<hstring const*>(&query), *reinterpret_cast<hstring const*>(&inputLanguage), *reinterpret_cast<hstring const*>(&correlationId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4>
    {
        int32_t __stdcall CreateAllowList(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList>(this->shim().CreateAllowList());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsQueryBlocked(void* query, void* inputLanguage, void* correlationId, void* allowList, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsQueryBlocked(*reinterpret_cast<hstring const*>(&query), *reinterpret_cast<hstring const*>(&inputLanguage), *reinterpret_cast<hstring const*>(&correlationId), *reinterpret_cast<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList const*>(&allowList)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindMatches(void* query, void* inputLanguage, void* correlationId, void* allowList, uint32_t* __resultSize, void*** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().FindMatches(*reinterpret_cast<hstring const*>(&query), *reinterpret_cast<hstring const*>(&inputLanguage), *reinterpret_cast<hstring const*>(&correlationId), *reinterpret_cast<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList const*>(&allowList)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession>
    {
        int32_t __stdcall GetQueryParametersAsync(void* naturalLanguageQuery, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearchInternal::QueryParametersInternal>>(this->shim().GetQueryParametersAsync(*reinterpret_cast<hstring const*>(&naturalLanguageQuery)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession2> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession2>
    {
        int32_t __stdcall GetQueryParametersAsync(void* naturalLanguageQuery, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::SemanticSearchInternal::QueryParametersInternal>>(this->shim().GetQueryParametersAsync(*reinterpret_cast<hstring const*>(&naturalLanguageQuery), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession3> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession3>
    {
        int32_t __stdcall GetQueryParameters(void* naturalLanguageQuery, uint32_t priority, uint32_t frequency, struct struct_Microsoft_Windows_SemanticSearchInternal_QueryParametersInternal* result) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::SemanticSearchInternal::QueryParametersInternal>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::SemanticSearchInternal::QueryParametersInternal>(this->shim().GetQueryParameters(*reinterpret_cast<hstring const*>(&naturalLanguageQuery), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession>
    {
        int32_t __stdcall CreateAsync(void* text, uint32_t __valuesSize, float* values, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateAsync(*reinterpret_cast<hstring const*>(&text), array_view<float>(reinterpret_cast<float*>(values), reinterpret_cast<float*>(values) + __valuesSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromTokensAsync(uint32_t __tokensSize, int64_t* tokens, uint32_t __valuesSize, float* values, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateFromTokensAsync(array_view<int64_t const>(reinterpret_cast<int64_t const *>(tokens), reinterpret_cast<int64_t const *>(tokens) + __tokensSize), array_view<float>(reinterpret_cast<float*>(values), reinterpret_cast<float*>(values) + __valuesSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Create(void* text, uint32_t __valuesSize, float* values) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Create(*reinterpret_cast<hstring const*>(&text), array_view<float>(reinterpret_cast<float*>(values), reinterpret_cast<float*>(values) + __valuesSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromTokens(uint32_t __tokensSize, int64_t* tokens, uint32_t __valuesSize, float* values) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CreateFromTokens(array_view<int64_t const>(reinterpret_cast<int64_t const *>(tokens), reinterpret_cast<int64_t const *>(tokens) + __tokensSize), array_view<float>(reinterpret_cast<float*>(values), reinterpret_cast<float*>(values) + __valuesSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OutputLength(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().OutputLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VectorSpaceId(winrt::guid* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::guid>(this->shim().VectorSpaceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ModelVersion(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ModelVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2>
    {
        int32_t __stdcall CreateAsync(void* text, uint32_t __valuesSize, float* values, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateAsync(*reinterpret_cast<hstring const*>(&text), array_view<float>(reinterpret_cast<float*>(values), reinterpret_cast<float*>(values) + __valuesSize), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromTokensAsync(uint32_t __tokensSize, int64_t* tokens, uint32_t __valuesSize, float* values, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateFromTokensAsync(array_view<int64_t const>(reinterpret_cast<int64_t const *>(tokens), reinterpret_cast<int64_t const *>(tokens) + __tokensSize), array_view<float>(reinterpret_cast<float*>(values), reinterpret_cast<float*>(values) + __valuesSize), priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Create(void* text, uint32_t __valuesSize, float* values, uint32_t priority, uint32_t frequency) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Create(*reinterpret_cast<hstring const*>(&text), array_view<float>(reinterpret_cast<float*>(values), reinterpret_cast<float*>(values) + __valuesSize), priority, frequency);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromTokens(uint32_t __tokensSize, int64_t* tokens, uint32_t __valuesSize, float* values, uint32_t priority, uint32_t frequency) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CreateFromTokens(array_view<int64_t const>(reinterpret_cast<int64_t const *>(tokens), reinterpret_cast<int64_t const *>(tokens) + __tokensSize), array_view<float>(reinterpret_cast<float*>(values), reinterpret_cast<float*>(values) + __valuesSize), priority, frequency);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession>
    {
        int32_t __stdcall ShouldTokenize(uint64_t charCount, uint64_t maxTokenCount, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().ShouldTokenize(charCount, maxTokenCount));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Tokenize(uint64_t maxTokenCount, void* text, uint32_t __tokensSize, int64_t* tokens, uint64_t* tokensUsed, uint32_t __indicesSize, uint64_t* indices, uint64_t* indicesUsed) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Tokenize(maxTokenCount, *reinterpret_cast<hstring const*>(&text), array_view<int64_t>(reinterpret_cast<int64_t*>(tokens), reinterpret_cast<int64_t*>(tokens) + __tokensSize), *tokensUsed, array_view<uint64_t>(reinterpret_cast<uint64_t*>(indices), reinterpret_cast<uint64_t*>(indices) + __indicesSize), *indicesUsed);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ModelVersion(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ModelVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession2> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession2>
    {
        int32_t __stdcall Tokenize(uint64_t maxTokenCount, void* text, uint32_t __tokensSize, int64_t* tokens, uint64_t* tokensUsed, uint32_t __indicesSize, uint64_t* indices, uint64_t* indicesUsed, uint32_t priority, uint32_t frequency) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Tokenize(maxTokenCount, *reinterpret_cast<hstring const*>(&text), array_view<int64_t>(reinterpret_cast<int64_t*>(tokens), reinterpret_cast<int64_t*>(tokens) + __tokensSize), *tokensUsed, array_view<uint64_t>(reinterpret_cast<uint64_t*>(indices), reinterpret_cast<uint64_t*>(indices) + __indicesSize), *indicesUsed, priority, frequency);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession>
    {
        int32_t __stdcall GetTopicsAsync(void* text, uint32_t maxCount, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::SemanticSearchInternal::TopicInternal>>>(this->shim().GetTopicsAsync(*reinterpret_cast<hstring const*>(&text), maxCount));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetTopics(void* text, uint32_t maxCount, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::SemanticSearchInternal::TopicInternal>>(this->shim().GetTopics(*reinterpret_cast<hstring const*>(&text), maxCount));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDisplayName(void* className, void* languageTag, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDisplayName(*reinterpret_cast<hstring const*>(&className), *reinterpret_cast<hstring const*>(&languageTag)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ModelVersion(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ModelVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2> : produce_base<D, winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2>
    {
        int32_t __stdcall GetTopicsAsync(void* text, uint32_t maxCount, uint32_t priority, uint32_t frequency, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::SemanticSearchInternal::TopicInternal>>>(this->shim().GetTopicsAsync(*reinterpret_cast<hstring const*>(&text), maxCount, priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetTopics(void* text, uint32_t maxCount, uint32_t priority, uint32_t frequency, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::Windows::SemanticSearchInternal::TopicInternal>>(this->shim().GetTopics(*reinterpret_cast<hstring const*>(&text), maxCount, priority, frequency));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::SemanticSearchInternal
{
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchImageEmbeddingsSession4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IImageSearchTextEmbeddingsSession4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryAllowList> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListMatch2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryBlockListSession4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::IQueryProcessorSession3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::ISemanticTextSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::ITokenizerSession2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::SemanticSearchInternal::ITopicProcessorSession2> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
