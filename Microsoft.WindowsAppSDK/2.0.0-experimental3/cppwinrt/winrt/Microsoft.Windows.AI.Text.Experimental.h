// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_AI_Text_Experimental_H
#define WINRT_Microsoft_Windows_AI_Text_Experimental_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Windows.AI.Text.h"
#include "winrt/impl/Microsoft.Windows.AI.ContentSafety.2.h"
#include "winrt/impl/Microsoft.Windows.AI.Foundation.2.h"
#include "winrt/impl/Microsoft.Windows.AI.Text.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Storage.Streams.2.h"
#include "winrt/impl/Microsoft.Windows.AI.Text.Experimental.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelExperimental<D>::LoadAdapter(param::hstring const& filePath) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAdapter(*(void**)(&filePath), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)this;
            check_hresult(_winrt_abi_type->LoadAdapter(*(void**)(&filePath), &result));
        }
        return winrt::Microsoft::Windows::AI::Text::Experimental::LowRankAdaptation{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelExperimental<D>::LoadAdapter(winrt::Windows::Storage::Streams::IBuffer const& buffer) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAdapter2(*(void**)(&buffer), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)this;
            check_hresult(_winrt_abi_type->LoadAdapter2(*(void**)(&buffer), &result));
        }
        return winrt::Microsoft::Windows::AI::Text::Experimental::LowRankAdaptation{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelExperimental<D>::GenerateResponseAsync(param::hstring const& prompt, winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental const& options) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateResponseAsync(*(void**)(&prompt), *(void**)(&options), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)this;
            check_hresult(_winrt_abi_type->GenerateResponseAsync(*(void**)(&prompt), *(void**)(&options), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelExperimental<D>::GenerateResponseAsync(winrt::Microsoft::Windows::AI::Text::LanguageModelContext const& context, param::hstring const& prompt, winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental const& options) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateResponseAsync2(*(void**)(&context), *(void**)(&prompt), *(void**)(&options), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)this;
            check_hresult(_winrt_abi_type->GenerateResponseAsync2(*(void**)(&context), *(void**)(&prompt), *(void**)(&options), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelExperimental<D>::GenerateResponseFromEmbeddingsAsync(param::async_iterable<winrt::Microsoft::Windows::AI::Foundation::EmbeddingVector> const& promptEmbedding, winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental const& options) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateResponseFromEmbeddingsAsync(*(void**)(&promptEmbedding), *(void**)(&options), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)this;
            check_hresult(_winrt_abi_type->GenerateResponseFromEmbeddingsAsync(*(void**)(&promptEmbedding), *(void**)(&options), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelExperimental<D>::GenerateResponseFromEmbeddingsAsync(winrt::Microsoft::Windows::AI::Text::LanguageModelContext const& context, param::async_iterable<winrt::Microsoft::Windows::AI::Foundation::EmbeddingVector> const& promptEmbedding, winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental const& options) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GenerateResponseFromEmbeddingsAsync2(*(void**)(&context), *(void**)(&promptEmbedding), *(void**)(&options), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>**)this;
            check_hresult(_winrt_abi_type->GenerateResponseFromEmbeddingsAsync2(*(void**)(&context), *(void**)(&promptEmbedding), *(void**)(&options), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelExperimentalFactory<D>::CreateInstance(winrt::Microsoft::Windows::AI::Text::LanguageModel const& languageModel) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimentalFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimentalFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimentalFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&languageModel), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimentalFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&languageModel), &value));
        }
        return winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelExperimental{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::Temperature() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Temperature(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->get_Temperature(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::Temperature(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Temperature(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->put_Temperature(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::TopP() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopP(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->get_TopP(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::TopP(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TopP(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->put_TopP(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::TopK() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopK(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->get_TopK(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::TopK(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TopK(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->put_TopK(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::ContentFilterOptions() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentFilterOptions(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->get_ContentFilterOptions(&value));
        }
        return winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::ContentFilterOptions(winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ContentFilterOptions(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->put_ContentFilterOptions(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::LoraAdapter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LoraAdapter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->get_LoraAdapter(&value));
        }
        return winrt::Microsoft::Windows::AI::Text::Experimental::LowRankAdaptation{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimental<D>::LoraAdapter(winrt::Microsoft::Windows::AI::Text::Experimental::LowRankAdaptation const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LoraAdapter(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>**)this;
            check_hresult(_winrt_abi_type->put_LoraAdapter(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_Experimental_ILanguageModelOptionsExperimentalStatics<D>::GetForLanguageModelOptions(winrt::Microsoft::Windows::AI::Text::LanguageModelOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimentalStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimentalStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimentalStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForLanguageModelOptions(*(void**)(&options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimentalStatics>**)this;
            check_hresult(_winrt_abi_type->GetForLanguageModelOptions(*(void**)(&options), &result));
        }
        return winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental{ result, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental> : produce_base<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental>
    {
        int32_t __stdcall LoadAdapter(void* filePath, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Text::Experimental::LowRankAdaptation>(this->shim().LoadAdapter(*reinterpret_cast<hstring const*>(&filePath)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAdapter2(void* buffer, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Text::Experimental::LowRankAdaptation>(this->shim().LoadAdapter(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GenerateResponseAsync(void* prompt, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>>(this->shim().GenerateResponseAsync(*reinterpret_cast<hstring const*>(&prompt), *reinterpret_cast<winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GenerateResponseAsync2(void* context, void* prompt, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>>(this->shim().GenerateResponseAsync(*reinterpret_cast<winrt::Microsoft::Windows::AI::Text::LanguageModelContext const*>(&context), *reinterpret_cast<hstring const*>(&prompt), *reinterpret_cast<winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GenerateResponseFromEmbeddingsAsync(void* promptEmbedding, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>>(this->shim().GenerateResponseFromEmbeddingsAsync(*reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::Windows::AI::Foundation::EmbeddingVector> const*>(&promptEmbedding), *reinterpret_cast<winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GenerateResponseFromEmbeddingsAsync2(void* context, void* promptEmbedding, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>>(this->shim().GenerateResponseFromEmbeddingsAsync(*reinterpret_cast<winrt::Microsoft::Windows::AI::Text::LanguageModelContext const*>(&context), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::Windows::AI::Foundation::EmbeddingVector> const*>(&promptEmbedding), *reinterpret_cast<winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimentalFactory> : produce_base<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimentalFactory>
    {
        int32_t __stdcall CreateInstance(void* languageModel, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelExperimental>(this->shim().CreateInstance(*reinterpret_cast<winrt::Microsoft::Windows::AI::Text::LanguageModel const*>(&languageModel)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental> : produce_base<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental>
    {
        int32_t __stdcall get_Temperature(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().Temperature());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Temperature(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Temperature(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopP(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().TopP());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TopP(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TopP(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopK(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().TopK());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TopK(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TopK(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentFilterOptions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions>(this->shim().ContentFilterOptions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ContentFilterOptions(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ContentFilterOptions(*reinterpret_cast<winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LoraAdapter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Text::Experimental::LowRankAdaptation>(this->shim().LoraAdapter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LoraAdapter(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LoraAdapter(*reinterpret_cast<winrt::Microsoft::Windows::AI::Text::Experimental::LowRankAdaptation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimentalStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimentalStatics>
    {
        int32_t __stdcall GetForLanguageModelOptions(void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental>(this->shim().GetForLanguageModelOptions(*reinterpret_cast<winrt::Microsoft::Windows::AI::Text::LanguageModelOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILowRankAdaptation> : produce_base<D, winrt::Microsoft::Windows::AI::Text::Experimental::ILowRankAdaptation>
    {
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::AI::Text::Experimental
{
    inline LanguageModelExperimental::LanguageModelExperimental(winrt::Microsoft::Windows::AI::Text::LanguageModel const& languageModel) :
        LanguageModelExperimental(impl::call_factory<LanguageModelExperimental, ILanguageModelExperimentalFactory>([&](ILanguageModelExperimentalFactory const& f) { return f.CreateInstance(languageModel); }))
    {
    }
    inline LanguageModelOptionsExperimental::LanguageModelOptionsExperimental() :
        LanguageModelOptionsExperimental(impl::call_factory_cast<LanguageModelOptionsExperimental(*)(winrt::Windows::Foundation::IActivationFactory const&), LanguageModelOptionsExperimental>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<LanguageModelOptionsExperimental>(); }))
    {
    }
    inline auto LanguageModelOptionsExperimental::GetForLanguageModelOptions(winrt::Microsoft::Windows::AI::Text::LanguageModelOptions const& options)
    {
        return impl::call_factory<LanguageModelOptionsExperimental, ILanguageModelOptionsExperimentalStatics>([&](ILanguageModelOptionsExperimentalStatics const& f) { return f.GetForLanguageModelOptions(options); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimental> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelExperimentalFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimental> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::Experimental::ILanguageModelOptionsExperimentalStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::Experimental::ILowRankAdaptation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelExperimental> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::Experimental::LanguageModelOptionsExperimental> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::Experimental::LowRankAdaptation> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
