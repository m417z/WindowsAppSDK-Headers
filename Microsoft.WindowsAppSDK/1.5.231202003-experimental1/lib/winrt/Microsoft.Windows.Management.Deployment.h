// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.220110.5

#pragma once
#ifndef WINRT_Microsoft_Windows_Management_Deployment_H
#define WINRT_Microsoft_Windows_Management_Deployment_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.220110.5"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.220110.5"
#include "winrt/impl/Microsoft.Windows.ApplicationModel.DynamicDependency.2.h"
#include "winrt/impl/Windows.ApplicationModel.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Microsoft.Windows.Management.Deployment.2.h"
namespace winrt::impl
{
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageVolume) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::TargetVolume() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_TargetVolume(&value));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::TargetVolume(winrt::Microsoft::Windows::Management::Deployment::PackageVolume const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_TargetVolume(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DependencyPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_DependencyPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<hstring>) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::OptionalPackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_OptionalPackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::OptionalPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_OptionalPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RelatedPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_RelatedPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Uri) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ExternalLocationUri() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ExternalLocationUri(&value));
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ExternalLocationUri(winrt::Windows::Foundation::Uri const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_ExternalLocationUri(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::StubPackageOption) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::StubPackageOption() const
    {
        winrt::Microsoft::Windows::Management::Deployment::StubPackageOption value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_StubPackageOption(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::StubPackageOption(winrt::Microsoft::Windows::Management::Deployment::StubPackageOption const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_StubPackageOption(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::AllowUnsigned() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_AllowUnsigned(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::AllowUnsigned(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_AllowUnsigned(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DeveloperMode() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_DeveloperMode(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DeveloperMode(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_DeveloperMode(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceAppShutdown() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ForceAppShutdown(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceAppShutdown(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_ForceAppShutdown(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceTargetAppShutdown() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ForceTargetAppShutdown(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceTargetAppShutdown(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_ForceTargetAppShutdown(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceUpdateFromAnyVersion() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ForceUpdateFromAnyVersion(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceUpdateFromAnyVersion(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_ForceUpdateFromAnyVersion(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::InstallAllResources() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_InstallAllResources(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::InstallAllResources(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_InstallAllResources(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RequiredContentGroupOnly() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_RequiredContentGroupOnly(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RequiredContentGroupOnly(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_RequiredContentGroupOnly(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RetainFilesOnFailure() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_RetainFilesOnFailure(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RetainFilesOnFailure(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_RetainFilesOnFailure(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::StageInPlace() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_StageInPlace(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::StageInPlace(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_StageInPlace(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DeferRegistrationWhenPackagesAreInUse() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_DeferRegistrationWhenPackagesAreInUse(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DeferRegistrationWhenPackagesAreInUse(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_DeferRegistrationWhenPackagesAreInUse(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::IsExpectedDigestsSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_IsExpectedDigestsSupported(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ExpectedDigests() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ExpectedDigests(&value));
        return winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::IsLimitToExistingPackagesSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_IsLimitToExistingPackagesSupported(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::LimitToExistingPackages() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_LimitToExistingPackages(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::LimitToExistingPackages(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_LimitToExistingPackages(value));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel) consume_Microsoft_Windows_Management_Deployment_IAddPackageSetOptions<D>::DeploymentProcessingModel() const
    {
        winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageSetOptions)->get_DeploymentProcessingModel(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageSetOptions<D>::DeploymentProcessingModel(winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageSetOptions)->put_DeploymentProcessingModel(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority) consume_Microsoft_Windows_Management_Deployment_IAddPackageSetOptions<D>::DeploymentPriority() const
    {
        winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageSetOptions)->get_DeploymentPriority(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageSetOptions<D>::DeploymentPriority(winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageSetOptions)->put_DeploymentPriority(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions) consume_Microsoft_Windows_Management_Deployment_IAddPackageSetOptions<D>::AddPackageOptions() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageSetOptions)->get_AddPackageOptions(&value));
        return winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IAddPackageSetOptions<D>::AddPackageOptions(winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageSetOptions)->put_AddPackageOptions(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel) consume_Microsoft_Windows_Management_Deployment_IEnsureIsReadyOptions<D>::DeploymentProcessingModel() const
    {
        winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IEnsureIsReadyOptions)->get_DeploymentProcessingModel(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IEnsureIsReadyOptions<D>::DeploymentProcessingModel(winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IEnsureIsReadyOptions)->put_DeploymentProcessingModel(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority) consume_Microsoft_Windows_Management_Deployment_IEnsureIsReadyOptions<D>::DeploymentPriority() const
    {
        winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IEnsureIsReadyOptions)->get_DeploymentPriority(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IEnsureIsReadyOptions<D>::DeploymentPriority(winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IEnsureIsReadyOptions)->put_DeploymentPriority(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IFindPackageSetOptions<D>::TODO_MustHaveAtLeastOneInterfaceOrStaticFactoryPlaceholder() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IFindPackageSetOptions)->get_TODO_MustHaveAtLeastOneInterfaceOrStaticFactoryPlaceholder(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IFindPackageSetOptions<D>::TODO_MustHaveAtLeastOneInterfaceOrStaticFactoryPlaceholder(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IFindPackageSetOptions)->put_TODO_MustHaveAtLeastOneInterfaceOrStaticFactoryPlaceholder(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::IsPackageSetReady(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->IsPackageSetReady(*(void**)(&packageSet), &result));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::IsPackageSetReadyById(param::hstring const& packageSetId) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->IsPackageSetReadyById(*(void**)(&packageSetId), &result));
        return result;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::EnsurePackageSetIsReadyAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::Management::Deployment::EnsureIsReadyOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->EnsurePackageSetIsReadyAsync(*(void**)(&packageSet), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::EnsurePackageSetIsReadyByIdAsync(param::hstring const& packageSetId, winrt::Microsoft::Windows::Management::Deployment::EnsureIsReadyOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->EnsurePackageSetIsReadyByIdAsync(*(void**)(&packageSetId), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::AddPackageAsync(param::hstring const& package, winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->AddPackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::AddPackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri, winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->AddPackageByUriAsync(*(void**)(&packageUri), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::AddPackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::Management::Deployment::AddPackageSetOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->AddPackageSetAsync(*(void**)(&packageSet), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::AddPackageSetByIdAsync(param::hstring const& packageSetId, winrt::Microsoft::Windows::Management::Deployment::AddPackageSetOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->AddPackageSetByIdAsync(*(void**)(&packageSetId), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageAsync(param::hstring const& package, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageByFullNameAsync(param::hstring const& packageFullName, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageByFullNameAsync(*(void**)(&packageFullName), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageByFamilyNameAsync(param::hstring const& packageFamilyName, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageByFamilyNameAsync(*(void**)(&packageFamilyName), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageSetAsync(*(void**)(&packageSet), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageSetByIdAsync(param::hstring const& packageSetId, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageSetByIdAsync(*(void**)(&packageSetId), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManagerStatics<D>::GetDefault() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManagerStatics)->GetDefault(&result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgressStatus) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentProgress<D>::status() const
    {
        winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgressStatus value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentProgress)->get_status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentProgress<D>::status(winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgressStatus const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentProgress)->put_status(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(double) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentProgress<D>::percentage() const
    {
        double value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentProgress)->get_percentage(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentProgress<D>::percentage(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentProgress)->put_percentage(value));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentStatus) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<D>::Status() const
    {
        winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentStatus value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult)->get_Status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::hresult) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<D>::ExtendedError() const
    {
        winrt::hresult value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult)->get_ExtendedError(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<D>::IsRegistered() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult)->get_IsRegistered(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::guid) consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<D>::ActivityId() const
    {
        winrt::guid value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult)->get_ActivityId(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition) consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::AddPackageSet(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager)->AddPackageSet(*(void**)(&packageSet), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition) consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::AddPackageSet(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const& createOptions, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions const& addOptions) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager)->AddPackageSetWithOptions(*(void**)(&packageSet), *(void**)(&createOptions), *(void**)(&addOptions), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition) consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::AddPackageSetById(param::hstring const& packageSetId) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager)->AddPackageSetById(*(void**)(&packageSetId), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition) consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::AddPackageSetById(param::hstring const& packageSetId, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const& createOptions, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions const& addOptions) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager)->AddPackageSetByIdWithOptions(*(void**)(&packageSetId), *(void**)(&createOptions), *(void**)(&addOptions), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::RemovePackageSet(winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition const& packageSetRuntimeDisposition) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager)->RemovePackageSet(*(void**)(&packageSetRuntimeDisposition)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager) consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManagerStatics<D>::GetDefault() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManagerStatics)->GetDefault(&result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::Id() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSet)->get_Id(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::Id(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSet)->put_Id(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>) consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::PackageSetItems() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSet)->get_PackageSetItems(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::Id() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_Id(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::Id(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_Id(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::PackageFamilyName() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_PackageFamilyName(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::PackageFamilyName(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_PackageFamilyName(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::ApplicationModel::PackageVersion) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::MinVersion() const
    {
        winrt::Windows::ApplicationModel::PackageVersion value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_MinVersion(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::MinVersion(winrt::Windows::ApplicationModel::PackageVersion const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_MinVersion(impl::bind_in(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::ProcessorArchitectureFilter() const
    {
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_ProcessorArchitectureFilter(reinterpret_cast<uint32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::ProcessorArchitectureFilter(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_ProcessorArchitectureFilter(static_cast<uint32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Uri) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::PackageUri() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_PackageUri(&value));
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::PackageUri(winrt::Windows::Foundation::Uri const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_PackageUri(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<D>::PackageSetItemId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition)->get_PackageSetItemId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<D>::PackageFullName() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition)->get_PackageFullName(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<D>::PackageDependencyId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition)->get_PackageDependencyId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId) consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<D>::PackageDependencyContextId() const
    {
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition)->get_PackageDependencyContextId(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSetManager<D>::Add(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetManager)->Add(*(void**)(&packageSet)));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSetManager<D>::Update(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetManager)->Update(*(void**)(&packageSet)));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSetManager<D>::Remove(param::hstring const& packageSetId) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetManager)->Remove(*(void**)(&packageSetId)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageSet) consume_Microsoft_Windows_Management_Deployment_IPackageSetManager<D>::Get(param::hstring const& packageSetId) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetManager)->Get(*(void**)(&packageSetId), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageSet{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSet>) consume_Microsoft_Windows_Management_Deployment_IPackageSetManager<D>::Find(winrt::Microsoft::Windows::Management::Deployment::FindPackageSetOptions const& options) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetManager)->Find(*(void**)(&options), &result));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSet>{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageSetManager) consume_Microsoft_Windows_Management_Deployment_IPackageSetManagerStatics<D>::GetDefault() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetManagerStatics)->GetDefault(&result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageSetManager{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageSetRuntimeDisposition<D>::PackageSetId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition)->get_PackageSetId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageSetRuntimeDisposition<D>::PackageSetId(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition)->put_PackageSetId(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition>) consume_Microsoft_Windows_Management_Deployment_IPackageSetRuntimeDisposition<D>::PackageSetItemRuntimeDispositions() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition)->get_PackageSetItemRuntimeDispositions(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::IsSystemVolume() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_IsSystemVolume(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::MountPoint() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_MountPoint(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::Name() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_Name(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::PackageStorePath() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_PackageStorePath(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::SupportsHardLinks() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_SupportsHardLinks(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::IsFullTrustPackageSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_IsFullTrustPackageSupported(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::IsAppxInstallSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_IsAppxInstallSupported(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageVolumeStatus) consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::Status() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_Status(&value));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolumeStatus{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::FixMe() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->FixMe());
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeManagerStatics<D>::FindPackageVolumes() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeManagerStatics)->FindPackageVolumes(&result));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageVolume) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeManagerStatics<D>::FindPackageVolumeByPath(param::hstring const& path) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeManagerStatics)->FindPackageVolumeByPath(*(void**)(&path), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageVolume) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeManagerStatics<D>::FindPackageVolumeByMediaId(param::hstring const& mediaId) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeManagerStatics)->FindPackageVolumeByMediaId(*(void**)(&mediaId), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageVolume) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeManagerStatics<D>::FindPackageVolumeByName(param::hstring const& name) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeManagerStatics)->FindPackageVolumeByName(*(void**)(&name), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatus<D>::IsOK() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatus)->get_IsOK(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatus<D>::IsOK(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatus)->put_IsOK(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatus<D>::IsOffline() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatus)->get_IsOffline(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatus<D>::IsOffline(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatus)->put_IsOffline(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatus<D>::IsBroken() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatus)->get_IsBroken(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatus<D>::IsBroken(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatus)->put_IsBroken(value));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageVolume) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::AppDataVolume() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_AppDataVolume(&value));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::AppDataVolume(winrt::Microsoft::Windows::Management::Deployment::PackageVolume const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_AppDataVolume(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DependencyPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_DependencyPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<hstring>) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::OptionalPackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_OptionalPackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Uri) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ExternalLocationUri() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ExternalLocationUri(&value));
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ExternalLocationUri(winrt::Windows::Foundation::Uri const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_ExternalLocationUri(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DeveloperMode() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_DeveloperMode(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DeveloperMode(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_DeveloperMode(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceAppShutdown() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ForceAppShutdown(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceAppShutdown(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_ForceAppShutdown(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceTargetAppShutdown() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ForceTargetAppShutdown(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceTargetAppShutdown(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_ForceTargetAppShutdown(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceUpdateFromAnyVersion() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ForceUpdateFromAnyVersion(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceUpdateFromAnyVersion(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_ForceUpdateFromAnyVersion(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::InstallAllResources() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_InstallAllResources(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::InstallAllResources(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_InstallAllResources(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::StageInPlace() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_StageInPlace(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::StageInPlace(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_StageInPlace(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::AllowUnsigned() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_AllowUnsigned(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::AllowUnsigned(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_AllowUnsigned(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DeferRegistrationWhenPackagesAreInUse() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_DeferRegistrationWhenPackagesAreInUse(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DeferRegistrationWhenPackagesAreInUse(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_DeferRegistrationWhenPackagesAreInUse(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::IsExpectedDigestsSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_IsExpectedDigestsSupported(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>) consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ExpectedDigests() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ExpectedDigests(&value));
        return winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::PreserveApplicationData() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->get_PreserveApplicationData(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::PreserveApplicationData(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->put_PreserveApplicationData(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::PreserveRoamableApplicationData() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->get_PreserveRoamableApplicationData(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::PreserveRoamableApplicationData(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->put_PreserveRoamableApplicationData(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::RemoveForAllUsers() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->get_RemoveForAllUsers(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::RemoveForAllUsers(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->put_RemoveForAllUsers(value));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority) consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::Priority() const
    {
        winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->get_Priority(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::Priority(winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->put_Priority(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::PackageVolume) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::TargetVolume() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_TargetVolume(&value));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::TargetVolume(winrt::Microsoft::Windows::Management::Deployment::PackageVolume const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_TargetVolume(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::DependencyPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_DependencyPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<hstring>) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::OptionalPackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_OptionalPackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::OptionalPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_OptionalPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::RelatedPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_RelatedPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Uri) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ExternalLocationUri() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_ExternalLocationUri(&value));
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ExternalLocationUri(winrt::Windows::Foundation::Uri const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_ExternalLocationUri(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::Management::Deployment::StubPackageOption) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::StubPackageOption() const
    {
        winrt::Microsoft::Windows::Management::Deployment::StubPackageOption value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_StubPackageOption(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::StubPackageOption(winrt::Microsoft::Windows::Management::Deployment::StubPackageOption const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_StubPackageOption(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::DeveloperMode() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_DeveloperMode(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::DeveloperMode(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_DeveloperMode(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ForceUpdateFromAnyVersion() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_ForceUpdateFromAnyVersion(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ForceUpdateFromAnyVersion(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_ForceUpdateFromAnyVersion(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::InstallAllResources() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_InstallAllResources(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::InstallAllResources(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_InstallAllResources(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::RequiredContentGroupOnly() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_RequiredContentGroupOnly(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::RequiredContentGroupOnly(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_RequiredContentGroupOnly(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::StageInPlace() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_StageInPlace(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::StageInPlace(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_StageInPlace(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::AllowUnsigned() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_AllowUnsigned(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::AllowUnsigned(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_AllowUnsigned(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::IsExpectedDigestsSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_IsExpectedDigestsSupported(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>) consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ExpectedDigests() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_ExpectedDigests(&value));
        return winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>{ value, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions>
    {
        int32_t __stdcall get_TargetVolume(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().TargetVolume());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TargetVolume(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TargetVolume(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageVolume const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DependencyPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().DependencyPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().OptionalPackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().OptionalPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RelatedPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().RelatedPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExternalLocationUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().ExternalLocationUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExternalLocationUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExternalLocationUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StubPackageOption(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption>(this->shim().StubPackageOption());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StubPackageOption(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StubPackageOption(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowUnsigned(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowUnsigned());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowUnsigned(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowUnsigned(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeveloperMode(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeveloperMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeveloperMode(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeveloperMode(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceAppShutdown(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceAppShutdown());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceAppShutdown(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceAppShutdown(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceTargetAppShutdown(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceTargetAppShutdown());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceTargetAppShutdown(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceTargetAppShutdown(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceUpdateFromAnyVersion(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceUpdateFromAnyVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceUpdateFromAnyVersion(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceUpdateFromAnyVersion(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallAllResources(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().InstallAllResources());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstallAllResources(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstallAllResources(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RequiredContentGroupOnly(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RequiredContentGroupOnly());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RequiredContentGroupOnly(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RequiredContentGroupOnly(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RetainFilesOnFailure(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RetainFilesOnFailure());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RetainFilesOnFailure(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RetainFilesOnFailure(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StageInPlace(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().StageInPlace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StageInPlace(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StageInPlace(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeferRegistrationWhenPackagesAreInUse(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeferRegistrationWhenPackagesAreInUse());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeferRegistrationWhenPackagesAreInUse(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeferRegistrationWhenPackagesAreInUse(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpectedDigestsSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpectedDigestsSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpectedDigests(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>>(this->shim().ExpectedDigests());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsLimitToExistingPackagesSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsLimitToExistingPackagesSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LimitToExistingPackages(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().LimitToExistingPackages());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LimitToExistingPackages(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LimitToExistingPackages(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IAddPackageSetOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IAddPackageSetOptions>
    {
        int32_t __stdcall get_DeploymentProcessingModel(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel>(this->shim().DeploymentProcessingModel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeploymentProcessingModel(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeploymentProcessingModel(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeploymentPriority(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority>(this->shim().DeploymentPriority());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeploymentPriority(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeploymentPriority(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AddPackageOptions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions>(this->shim().AddPackageOptions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AddPackageOptions(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddPackageOptions(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IEnsureIsReadyOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IEnsureIsReadyOptions>
    {
        int32_t __stdcall get_DeploymentProcessingModel(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel>(this->shim().DeploymentProcessingModel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeploymentProcessingModel(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeploymentProcessingModel(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::DeploymentProcessingModel const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeploymentPriority(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority>(this->shim().DeploymentPriority());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeploymentPriority(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeploymentPriority(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IFindPackageSetOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IFindPackageSetOptions>
    {
        int32_t __stdcall get_TODO_MustHaveAtLeastOneInterfaceOrStaticFactoryPlaceholder(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().TODO_MustHaveAtLeastOneInterfaceOrStaticFactoryPlaceholder());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TODO_MustHaveAtLeastOneInterfaceOrStaticFactoryPlaceholder(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TODO_MustHaveAtLeastOneInterfaceOrStaticFactoryPlaceholder(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager>
    {
        int32_t __stdcall IsPackageSetReady(void* packageSet, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsPackageSetReady(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsPackageSetReadyById(void* packageSetId, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsPackageSetReadyById(*reinterpret_cast<hstring const*>(&packageSetId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsurePackageSetIsReadyAsync(void* packageSet, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().EnsurePackageSetIsReadyAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::EnsureIsReadyOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsurePackageSetIsReadyByIdAsync(void* packageSetId, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().EnsurePackageSetIsReadyByIdAsync(*reinterpret_cast<hstring const*>(&packageSetId), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::EnsureIsReadyOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().AddPackageAsync(*reinterpret_cast<hstring const*>(&package), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageByUriAsync(void* packageUri, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().AddPackageByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageSetAsync(void* packageSet, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().AddPackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::AddPackageSetOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageSetByIdAsync(void* packageSetId, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().AddPackageSetByIdAsync(*reinterpret_cast<hstring const*>(&packageSetId), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::AddPackageSetOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageAsync(*reinterpret_cast<hstring const*>(&package), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageByFullNameAsync(void* packageFullName, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageByFullNameAsync(*reinterpret_cast<hstring const*>(&packageFullName), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageByFamilyNameAsync(void* packageFamilyName, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageByFamilyNameAsync(*reinterpret_cast<hstring const*>(&packageFamilyName), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageSetAsync(void* packageSet, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageSetByIdAsync(void* packageSetId, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageSetByIdAsync(*reinterpret_cast<hstring const*>(&packageSetId), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManagerStatics> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManagerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentProgress> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentProgress>
    {
        int32_t __stdcall get_status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgressStatus>(this->shim().status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_status(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().status(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgressStatus const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_percentage(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().percentage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_percentage(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().percentage(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult>
    {
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsRegistered(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsRegistered());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActivityId(winrt::guid* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::guid>(this->shim().ActivityId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager>
    {
        int32_t __stdcall AddPackageSet(void* packageSet, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition>(this->shim().AddPackageSet(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageSetWithOptions(void* packageSet, void* createOptions, void* addOptions, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition>(this->shim().AddPackageSet(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const*>(&createOptions), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions const*>(&addOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageSetById(void* packageSetId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition>(this->shim().AddPackageSetById(*reinterpret_cast<hstring const*>(&packageSetId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageSetByIdWithOptions(void* packageSetId, void* createOptions, void* addOptions, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition>(this->shim().AddPackageSetById(*reinterpret_cast<hstring const*>(&packageSetId), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const*>(&createOptions), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions const*>(&addOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageSet(void* packageSetRuntimeDisposition) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RemovePackageSet(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition const*>(&packageSetRuntimeDisposition));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManagerStatics> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManagerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSet> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSet>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Id(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Id(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageSetItems(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>>(this->shim().PackageSetItems());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Id(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Id(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageFamilyName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageFamilyName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageFamilyName(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageFamilyName(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinVersion(struct struct_Windows_ApplicationModel_PackageVersion* value) noexcept final try
        {
            zero_abi<winrt::Windows::ApplicationModel::PackageVersion>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::PackageVersion>(this->shim().MinVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinVersion(struct struct_Windows_ApplicationModel_PackageVersion value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinVersion(*reinterpret_cast<winrt::Windows::ApplicationModel::PackageVersion const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProcessorArchitectureFilter(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures>(this->shim().ProcessorArchitectureFilter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProcessorArchitectureFilter(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProcessorArchitectureFilter(*reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().PackageUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition>
    {
        int32_t __stdcall get_PackageSetItemId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageSetItemId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageFullName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageFullName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageDependencyId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageDependencyId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageDependencyContextId(struct struct_Microsoft_Windows_ApplicationModel_DynamicDependency_PackageDependencyContextId* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>(this->shim().PackageDependencyContextId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetManager> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetManager>
    {
        int32_t __stdcall Add(void* packageSet) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Add(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Update(void* packageSet) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Update(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Remove(void* packageSetId) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Remove(*reinterpret_cast<hstring const*>(&packageSetId));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Get(void* packageSetId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(this->shim().Get(*reinterpret_cast<hstring const*>(&packageSetId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Find(void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSet>>(this->shim().Find(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::FindPackageSetOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetManagerStatics> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetManagerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageSetManager>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition>
    {
        int32_t __stdcall get_PackageSetId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageSetId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageSetId(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageSetId(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageSetItemRuntimeDispositions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition>>(this->shim().PackageSetItemRuntimeDispositions());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolume> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolume>
    {
        int32_t __stdcall get_IsSystemVolume(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsSystemVolume());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MountPoint(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().MountPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageStorePath(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageStorePath());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SupportsHardLinks(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().SupportsHardLinks());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsFullTrustPackageSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsFullTrustPackageSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAppxInstallSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAppxInstallSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolumeStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FixMe() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FixMe();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeManagerStatics> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeManagerStatics>
    {
        int32_t __stdcall FindPackageVolumes(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>>(this->shim().FindPackageVolumes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindPackageVolumeByPath(void* path, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().FindPackageVolumeByPath(*reinterpret_cast<hstring const*>(&path)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindPackageVolumeByMediaId(void* mediaId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().FindPackageVolumeByMediaId(*reinterpret_cast<hstring const*>(&mediaId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindPackageVolumeByName(void* name, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().FindPackageVolumeByName(*reinterpret_cast<hstring const*>(&name)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatus> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatus>
    {
        int32_t __stdcall get_IsOK(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsOK());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsOK(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsOK(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsOffline(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsOffline());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsOffline(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsOffline(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsBroken(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsBroken());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsBroken(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsBroken(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions>
    {
        int32_t __stdcall get_AppDataVolume(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().AppDataVolume());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AppDataVolume(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AppDataVolume(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageVolume const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DependencyPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().DependencyPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().OptionalPackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExternalLocationUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().ExternalLocationUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExternalLocationUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExternalLocationUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeveloperMode(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeveloperMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeveloperMode(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeveloperMode(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceAppShutdown(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceAppShutdown());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceAppShutdown(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceAppShutdown(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceTargetAppShutdown(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceTargetAppShutdown());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceTargetAppShutdown(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceTargetAppShutdown(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceUpdateFromAnyVersion(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceUpdateFromAnyVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceUpdateFromAnyVersion(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceUpdateFromAnyVersion(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallAllResources(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().InstallAllResources());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstallAllResources(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstallAllResources(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StageInPlace(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().StageInPlace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StageInPlace(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StageInPlace(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowUnsigned(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowUnsigned());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowUnsigned(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowUnsigned(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeferRegistrationWhenPackagesAreInUse(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeferRegistrationWhenPackagesAreInUse());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeferRegistrationWhenPackagesAreInUse(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeferRegistrationWhenPackagesAreInUse(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpectedDigestsSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpectedDigestsSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpectedDigests(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>>(this->shim().ExpectedDigests());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions>
    {
        int32_t __stdcall get_PreserveApplicationData(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().PreserveApplicationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreserveApplicationData(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreserveApplicationData(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreserveRoamableApplicationData(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().PreserveRoamableApplicationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreserveRoamableApplicationData(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreserveRoamableApplicationData(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RemoveForAllUsers(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RemoveForAllUsers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RemoveForAllUsers(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RemoveForAllUsers(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Priority(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority>(this->shim().Priority());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Priority(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Priority(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::DeploymentPriority const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions>
    {
        int32_t __stdcall get_TargetVolume(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().TargetVolume());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TargetVolume(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TargetVolume(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageVolume const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DependencyPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().DependencyPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().OptionalPackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().OptionalPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RelatedPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().RelatedPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExternalLocationUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().ExternalLocationUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExternalLocationUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExternalLocationUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StubPackageOption(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption>(this->shim().StubPackageOption());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StubPackageOption(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StubPackageOption(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeveloperMode(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeveloperMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeveloperMode(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeveloperMode(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceUpdateFromAnyVersion(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceUpdateFromAnyVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceUpdateFromAnyVersion(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceUpdateFromAnyVersion(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallAllResources(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().InstallAllResources());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstallAllResources(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstallAllResources(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RequiredContentGroupOnly(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RequiredContentGroupOnly());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RequiredContentGroupOnly(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RequiredContentGroupOnly(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StageInPlace(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().StageInPlace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StageInPlace(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StageInPlace(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowUnsigned(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowUnsigned());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowUnsigned(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowUnsigned(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpectedDigestsSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpectedDigestsSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpectedDigests(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>>(this->shim().ExpectedDigests());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::Management::Deployment
{
    inline AddPackageOptions::AddPackageOptions() :
        AddPackageOptions(impl::call_factory_cast<AddPackageOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), AddPackageOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<AddPackageOptions>(); }))
    {
    }
    inline AddPackageSetOptions::AddPackageSetOptions() :
        AddPackageSetOptions(impl::call_factory_cast<AddPackageSetOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), AddPackageSetOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<AddPackageSetOptions>(); }))
    {
    }
    inline EnsureIsReadyOptions::EnsureIsReadyOptions() :
        EnsureIsReadyOptions(impl::call_factory_cast<EnsureIsReadyOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), EnsureIsReadyOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<EnsureIsReadyOptions>(); }))
    {
    }
    inline FindPackageSetOptions::FindPackageSetOptions() :
        FindPackageSetOptions(impl::call_factory_cast<FindPackageSetOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), FindPackageSetOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<FindPackageSetOptions>(); }))
    {
    }
    inline auto PackageDeploymentManager::GetDefault()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager(*)(IPackageDeploymentManagerStatics const&), PackageDeploymentManager, IPackageDeploymentManagerStatics>([](IPackageDeploymentManagerStatics const& f) { return f.GetDefault(); });
    }
    inline auto PackageRuntimeManager::GetDefault()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager(*)(IPackageRuntimeManagerStatics const&), PackageRuntimeManager, IPackageRuntimeManagerStatics>([](IPackageRuntimeManagerStatics const& f) { return f.GetDefault(); });
    }
    inline PackageSet::PackageSet() :
        PackageSet(impl::call_factory_cast<PackageSet(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageSet>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageSet>(); }))
    {
    }
    inline PackageSetItem::PackageSetItem() :
        PackageSetItem(impl::call_factory_cast<PackageSetItem(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageSetItem>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageSetItem>(); }))
    {
    }
    inline PackageSetItemRuntimeDisposition::PackageSetItemRuntimeDisposition() :
        PackageSetItemRuntimeDisposition(impl::call_factory_cast<PackageSetItemRuntimeDisposition(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageSetItemRuntimeDisposition>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageSetItemRuntimeDisposition>(); }))
    {
    }
    inline auto PackageSetManager::GetDefault()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSetManager(*)(IPackageSetManagerStatics const&), PackageSetManager, IPackageSetManagerStatics>([](IPackageSetManagerStatics const& f) { return f.GetDefault(); });
    }
    inline PackageSetRuntimeDisposition::PackageSetRuntimeDisposition() :
        PackageSetRuntimeDisposition(impl::call_factory_cast<PackageSetRuntimeDisposition(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageSetRuntimeDisposition>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageSetRuntimeDisposition>(); }))
    {
    }
    inline PackageVolume::PackageVolume() :
        PackageVolume(impl::call_factory_cast<PackageVolume(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageVolume>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageVolume>(); }))
    {
    }
    inline auto PackageVolumeManager::FindPackageVolumes()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(*)(IPackageVolumeManagerStatics const&), PackageVolumeManager, IPackageVolumeManagerStatics>([](IPackageVolumeManagerStatics const& f) { return f.FindPackageVolumes(); });
    }
    inline auto PackageVolumeManager::FindPackageVolumeByPath(param::hstring const& path)
    {
        return impl::call_factory<PackageVolumeManager, IPackageVolumeManagerStatics>([&](IPackageVolumeManagerStatics const& f) { return f.FindPackageVolumeByPath(path); });
    }
    inline auto PackageVolumeManager::FindPackageVolumeByMediaId(param::hstring const& mediaId)
    {
        return impl::call_factory<PackageVolumeManager, IPackageVolumeManagerStatics>([&](IPackageVolumeManagerStatics const& f) { return f.FindPackageVolumeByMediaId(mediaId); });
    }
    inline auto PackageVolumeManager::FindPackageVolumeByName(param::hstring const& name)
    {
        return impl::call_factory<PackageVolumeManager, IPackageVolumeManagerStatics>([&](IPackageVolumeManagerStatics const& f) { return f.FindPackageVolumeByName(name); });
    }
    inline PackageVolumeStatus::PackageVolumeStatus() :
        PackageVolumeStatus(impl::call_factory_cast<PackageVolumeStatus(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageVolumeStatus>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageVolumeStatus>(); }))
    {
    }
    inline RegisterPackageOptions::RegisterPackageOptions() :
        RegisterPackageOptions(impl::call_factory_cast<RegisterPackageOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), RegisterPackageOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<RegisterPackageOptions>(); }))
    {
    }
    inline RemovePackageOptions::RemovePackageOptions() :
        RemovePackageOptions(impl::call_factory_cast<RemovePackageOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), RemovePackageOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<RemovePackageOptions>(); }))
    {
    }
    inline StagePackageOptions::StagePackageOptions() :
        StagePackageOptions(impl::call_factory_cast<StagePackageOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), StagePackageOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StagePackageOptions>(); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IAddPackageSetOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IEnsureIsReadyOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IFindPackageSetOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentProgress> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSet> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSetManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSetManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageVolume> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatus> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::AddPackageSetOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::EnsureIsReadyOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::FindPackageSetOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSet> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSetManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageVolume> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageVolumeManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageVolumeStatus> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
