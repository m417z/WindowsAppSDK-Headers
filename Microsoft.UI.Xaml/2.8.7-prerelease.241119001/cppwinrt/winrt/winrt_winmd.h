// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_winrt_winmd_H
#define WINRT_winrt_winmd_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/winrt_winmd.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_winrt_winmd_IConstant<D>::Type() const
    {
        winrt::winrt_winmd::ConstantType value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IConstant>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IConstant, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IConstant>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Type(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IConstant>**)this;
            check_hresult(_winrt_abi_type->get_Type(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IConstant<D>::Valid() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IConstant>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IConstant, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IConstant>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Valid(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IConstant>**)this;
            check_hresult(_winrt_abi_type->get_Valid(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IConstant<D>::ValueInt32() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IConstant>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IConstant, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IConstant>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ValueInt32(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IConstant>**)this;
            check_hresult(_winrt_abi_type->get_ValueInt32(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IConstant<D>::ValueUInt32() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IConstant>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IConstant, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IConstant>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ValueUInt32(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IConstant>**)this;
            check_hresult(_winrt_abi_type->get_ValueUInt32(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ICustomAttribute<D>::TypeNamespace() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ICustomAttribute>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ICustomAttribute, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttribute>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TypeNamespace(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttribute>**)this;
            check_hresult(_winrt_abi_type->get_TypeNamespace(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ICustomAttribute<D>::TypeName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ICustomAttribute>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ICustomAttribute, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttribute>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TypeName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttribute>**)this;
            check_hresult(_winrt_abi_type->get_TypeName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ICustomAttribute<D>::Value() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ICustomAttribute>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ICustomAttribute, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttribute>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttribute>**)this;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        return winrt::winrt_winmd::CustomAttributeSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ICustomAttributeSig<D>::FixedArgs() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ICustomAttributeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ICustomAttributeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttributeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FixedArgs(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttributeSig>**)this;
            check_hresult(_winrt_abi_type->get_FixedArgs(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::FixedArgSig>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ICustomAttributeSig<D>::NamedArgs() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ICustomAttributeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ICustomAttributeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttributeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NamedArgs(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ICustomAttributeSig>**)this;
            check_hresult(_winrt_abi_type->get_NamedArgs(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::NamedArgSig>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::HasSystemType() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasSystemType(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_HasSystemType(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::SystemType() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SystemType(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_SystemType(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::HasStringValue() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasStringValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_HasStringValue(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::StringValue() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StringValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_StringValue(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::HasInt32Value() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasInt32Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_HasInt32Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::Int32Value() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Int32Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_Int32Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::HasUInt32Value() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasUInt32Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_HasUInt32Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::UInt32Value() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UInt32Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_UInt32Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::HasUInt16Value() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasUInt16Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_HasUInt16Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::UInt16Value() const
    {
        uint16_t value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UInt16Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_UInt16Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::HasByteValue() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasByteValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_HasByteValue(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IElemSig<D>::ByteValue() const
    {
        uint8_t value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IElemSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IElemSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ByteValue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IElemSig>**)this;
            check_hresult(_winrt_abi_type->get_ByteValue(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IEvent<D>::Name() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IEvent>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IEvent, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)this;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IEvent<D>::CustomAttributes() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IEvent>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IEvent, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)this;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IEvent<D>::HasEventTypeDef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IEvent>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IEvent, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasEventTypeDef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)this;
            check_hresult(_winrt_abi_type->get_HasEventTypeDef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IEvent<D>::EventTypeDef() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IEvent>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IEvent, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EventTypeDef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)this;
            check_hresult(_winrt_abi_type->get_EventTypeDef(&value));
        }
        return winrt::winrt_winmd::TypeDef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IEvent<D>::HasEventTypeRef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IEvent>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IEvent, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasEventTypeRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)this;
            check_hresult(_winrt_abi_type->get_HasEventTypeRef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IEvent<D>::EventTypeRef() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IEvent>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IEvent, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EventTypeRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)this;
            check_hresult(_winrt_abi_type->get_EventTypeRef(&value));
        }
        return winrt::winrt_winmd::TypeRef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IEvent<D>::HasGenericTypeInstSig() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IEvent>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IEvent, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasGenericTypeInstSig(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)this;
            check_hresult(_winrt_abi_type->get_HasGenericTypeInstSig(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IEvent<D>::GenericTypeInstSig() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IEvent>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IEvent, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GenericTypeInstSig(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IEvent>**)this;
            check_hresult(_winrt_abi_type->get_GenericTypeInstSig(&value));
        }
        return winrt::winrt_winmd::GenericTypeInstSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IField<D>::Constant() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IField>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IField, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IField>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Constant(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IField>**)this;
            check_hresult(_winrt_abi_type->get_Constant(&value));
        }
        return winrt::winrt_winmd::Constant{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IField<D>::Name() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IField>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IField, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IField>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IField>**)this;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IField<D>::CustomAttributes() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IField>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IField, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IField>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IField>**)this;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IField<D>::Signature() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IField>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IField, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IField>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Signature(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IField>**)this;
            check_hresult(_winrt_abi_type->get_Signature(&value));
        }
        return winrt::winrt_winmd::FieldSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IFieldSig<D>::Type() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IFieldSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IFieldSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFieldSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFieldSig>**)this;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        return winrt::winrt_winmd::TypeSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IFixedArgSig<D>::HasElemSigs() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IFixedArgSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IFixedArgSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFixedArgSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasElemSigs(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFixedArgSig>**)this;
            check_hresult(_winrt_abi_type->get_HasElemSigs(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IFixedArgSig<D>::ElemSigs() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IFixedArgSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IFixedArgSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFixedArgSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ElemSigs(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFixedArgSig>**)this;
            check_hresult(_winrt_abi_type->get_ElemSigs(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::ElemSig>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IFixedArgSig<D>::HasElemSig() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IFixedArgSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IFixedArgSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFixedArgSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasElemSig(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFixedArgSig>**)this;
            check_hresult(_winrt_abi_type->get_HasElemSig(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IFixedArgSig<D>::ElemSig() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IFixedArgSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IFixedArgSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFixedArgSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ElemSig(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IFixedArgSig>**)this;
            check_hresult(_winrt_abi_type->get_ElemSig(&value));
        }
        return winrt::winrt_winmd::ElemSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IGenericTypeInstSig<D>::ClassOrValueType() const
    {
        winrt::winrt_winmd::ElementType value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IGenericTypeInstSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IGenericTypeInstSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ClassOrValueType(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)this;
            check_hresult(_winrt_abi_type->get_ClassOrValueType(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IGenericTypeInstSig<D>::HasGenericTypeDef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IGenericTypeInstSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IGenericTypeInstSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasGenericTypeDef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)this;
            check_hresult(_winrt_abi_type->get_HasGenericTypeDef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IGenericTypeInstSig<D>::GenericTypeDef() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IGenericTypeInstSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IGenericTypeInstSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GenericTypeDef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)this;
            check_hresult(_winrt_abi_type->get_GenericTypeDef(&value));
        }
        return winrt::winrt_winmd::TypeDef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IGenericTypeInstSig<D>::HasGenericTypeRef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IGenericTypeInstSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IGenericTypeInstSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasGenericTypeRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)this;
            check_hresult(_winrt_abi_type->get_HasGenericTypeRef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IGenericTypeInstSig<D>::GenericTypeRef() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IGenericTypeInstSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IGenericTypeInstSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GenericTypeRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)this;
            check_hresult(_winrt_abi_type->get_GenericTypeRef(&value));
        }
        return winrt::winrt_winmd::TypeRef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IGenericTypeInstSig<D>::GenericArgs() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IGenericTypeInstSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IGenericTypeInstSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GenericArgs(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IGenericTypeInstSig>**)this;
            check_hresult(_winrt_abi_type->get_GenericArgs(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeSig>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IInterfaceImpl<D>::Class() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IInterfaceImpl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IInterfaceImpl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Class(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)this;
            check_hresult(_winrt_abi_type->get_Class(&value));
        }
        return winrt::winrt_winmd::TypeDef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IInterfaceImpl<D>::HasTypeDef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IInterfaceImpl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IInterfaceImpl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasTypeDef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)this;
            check_hresult(_winrt_abi_type->get_HasTypeDef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IInterfaceImpl<D>::TypeDef() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IInterfaceImpl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IInterfaceImpl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TypeDef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)this;
            check_hresult(_winrt_abi_type->get_TypeDef(&value));
        }
        return winrt::winrt_winmd::TypeDef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IInterfaceImpl<D>::HasTypeRef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IInterfaceImpl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IInterfaceImpl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasTypeRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)this;
            check_hresult(_winrt_abi_type->get_HasTypeRef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IInterfaceImpl<D>::TypeRef() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IInterfaceImpl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IInterfaceImpl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TypeRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)this;
            check_hresult(_winrt_abi_type->get_TypeRef(&value));
        }
        return winrt::winrt_winmd::TypeRef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IInterfaceImpl<D>::HasGenericTypeInstSig() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IInterfaceImpl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IInterfaceImpl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasGenericTypeInstSig(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)this;
            check_hresult(_winrt_abi_type->get_HasGenericTypeInstSig(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IInterfaceImpl<D>::GenericTypeInstSig() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IInterfaceImpl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IInterfaceImpl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GenericTypeInstSig(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)this;
            check_hresult(_winrt_abi_type->get_GenericTypeInstSig(&value));
        }
        return winrt::winrt_winmd::GenericTypeInstSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IInterfaceImpl<D>::CustomAttributes() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IInterfaceImpl>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IInterfaceImpl, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IInterfaceImpl>**)this;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::Static() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Static(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Static(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::Final() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Final(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Final(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::Virtual() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Virtual(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Virtual(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::HideBySig() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HideBySig(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_HideBySig(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::Strict() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Strict(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Strict(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::Abstract() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Abstract(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Abstract(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::SpecialName() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SpecialName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_SpecialName(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::PInvokeImpl() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PInvokeImpl(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_PInvokeImpl(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::UnmanagedExport() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_UnmanagedExport(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_UnmanagedExport(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::RTSpecialName() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RTSpecialName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_RTSpecialName(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::HasSecurity() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasSecurity(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_HasSecurity(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodAttributes<D>::RequireSecObject() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RequireSecObject(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodAttributes>**)this;
            check_hresult(_winrt_abi_type->get_RequireSecObject(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodDef<D>::Name() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)this;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodDef<D>::Flags() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Flags(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)this;
            check_hresult(_winrt_abi_type->get_Flags(&value));
        }
        return winrt::winrt_winmd::MethodAttributes{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodDef<D>::SpecialName() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SpecialName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)this;
            check_hresult(_winrt_abi_type->get_SpecialName(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodDef<D>::Signature() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Signature(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)this;
            check_hresult(_winrt_abi_type->get_Signature(&value));
        }
        return winrt::winrt_winmd::MethodDefSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodDef<D>::ParamList() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ParamList(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)this;
            check_hresult(_winrt_abi_type->get_ParamList(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Param>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodDef<D>::CustomAttributes() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)this;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodDef<D>::Parent() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Parent(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDef>**)this;
            check_hresult(_winrt_abi_type->get_Parent(&value));
        }
        return winrt::winrt_winmd::TypeDef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodDefSig<D>::ReturnType() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodDefSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodDefSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDefSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ReturnType(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDefSig>**)this;
            check_hresult(_winrt_abi_type->get_ReturnType(&value));
        }
        return winrt::winrt_winmd::RetTypeSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodDefSig<D>::Params() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodDefSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodDefSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDefSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Params(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodDefSig>**)this;
            check_hresult(_winrt_abi_type->get_Params(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::ParamSig>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodSemantics<D>::Semantic() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodSemantics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodSemantics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemantics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Semantic(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemantics>**)this;
            check_hresult(_winrt_abi_type->get_Semantic(&value));
        }
        return winrt::winrt_winmd::MethodSemanticsAttributes{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IMethodSemanticsAttributes<D>::Setter() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodSemanticsAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodSemanticsAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Setter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Setter(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodSemanticsAttributes<D>::Getter() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodSemanticsAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodSemanticsAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Getter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Getter(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodSemanticsAttributes<D>::Other() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodSemanticsAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodSemanticsAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Other(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Other(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodSemanticsAttributes<D>::AddOn() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodSemanticsAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodSemanticsAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AddOn(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)this;
            check_hresult(_winrt_abi_type->get_AddOn(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodSemanticsAttributes<D>::RemoveOn() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodSemanticsAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodSemanticsAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RemoveOn(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)this;
            check_hresult(_winrt_abi_type->get_RemoveOn(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IMethodSemanticsAttributes<D>::Fire() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IMethodSemanticsAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IMethodSemanticsAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Fire(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IMethodSemanticsAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Fire(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_INamedArgSig<D>::Name() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::INamedArgSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::INamedArgSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamedArgSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamedArgSig>**)this;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_INamedArgSig<D>::Value() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::INamedArgSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::INamedArgSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamedArgSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamedArgSig>**)this;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        return winrt::winrt_winmd::FixedArgSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_INamespace<D>::Name() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::INamespace>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::INamespace, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)this;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_INamespace<D>::Classes() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::INamespace>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::INamespace, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Classes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)this;
            check_hresult(_winrt_abi_type->get_Classes(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_INamespace<D>::Delegates() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::INamespace>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::INamespace, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Delegates(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)this;
            check_hresult(_winrt_abi_type->get_Delegates(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_INamespace<D>::Enums() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::INamespace>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::INamespace, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Enums(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)this;
            check_hresult(_winrt_abi_type->get_Enums(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_INamespace<D>::Interfaces() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::INamespace>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::INamespace, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Interfaces(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)this;
            check_hresult(_winrt_abi_type->get_Interfaces(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_INamespace<D>::Structs() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::INamespace>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::INamespace, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Structs(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::INamespace>**)this;
            check_hresult(_winrt_abi_type->get_Structs(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IParam<D>::Name() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IParam>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IParam, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParam>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParam>**)this;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IParam<D>::Flags() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IParam>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IParam, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParam>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Flags(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParam>**)this;
            check_hresult(_winrt_abi_type->get_Flags(&value));
        }
        return winrt::winrt_winmd::ParamAttributes{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IParamAttributes<D>::In() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IParamAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IParamAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_In(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)this;
            check_hresult(_winrt_abi_type->get_In(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IParamAttributes<D>::Out() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IParamAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IParamAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Out(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Out(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IParamAttributes<D>::Optional() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IParamAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IParamAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Optional(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)this;
            check_hresult(_winrt_abi_type->get_Optional(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IParamAttributes<D>::HasDefault() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IParamAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IParamAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasDefault(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)this;
            check_hresult(_winrt_abi_type->get_HasDefault(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IParamAttributes<D>::HasFieldMarshal() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IParamAttributes>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IParamAttributes, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasFieldMarshal(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamAttributes>**)this;
            check_hresult(_winrt_abi_type->get_HasFieldMarshal(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IParamSig<D>::ByRef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IParamSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IParamSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ByRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamSig>**)this;
            check_hresult(_winrt_abi_type->get_ByRef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IParamSig<D>::Type() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IParamSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IParamSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IParamSig>**)this;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        return winrt::winrt_winmd::TypeSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IProperty<D>::Name() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IProperty>**)this;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IProperty<D>::Type() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IProperty>**)this;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        return winrt::winrt_winmd::PropertySig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IProperty<D>::MethodSemantic() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MethodSemantic(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IProperty>**)this;
            check_hresult(_winrt_abi_type->get_MethodSemantic(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::MethodSemantics>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IProperty<D>::CustomAttributes() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IProperty>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IProperty, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IProperty>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IProperty>**)this;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IPropertySig<D>::Type() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IPropertySig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IPropertySig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IPropertySig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IPropertySig>**)this;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        return winrt::winrt_winmd::TypeSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IRetTypeSig<D>::ByRef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IRetTypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IRetTypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRetTypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ByRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRetTypeSig>**)this;
            check_hresult(_winrt_abi_type->get_ByRef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IRetTypeSig<D>::HasType() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IRetTypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IRetTypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRetTypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasType(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRetTypeSig>**)this;
            check_hresult(_winrt_abi_type->get_HasType(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_IRetTypeSig<D>::Type() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IRetTypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IRetTypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRetTypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRetTypeSig>**)this;
            check_hresult(_winrt_abi_type->get_Type(&value));
        }
        return winrt::winrt_winmd::TypeSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IRoot<D>::Namespaces() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IRoot>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IRoot, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRoot>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Namespaces(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRoot>**)this;
            check_hresult(_winrt_abi_type->get_Namespaces(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Namespace>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IRoot<D>::Find(param::hstring const& namespaceName, param::hstring const& name) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IRoot>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IRoot, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRoot>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Find(*(void**)(&namespaceName), *(void**)(&name), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRoot>**)this;
            check_hresult(_winrt_abi_type->Find(*(void**)(&namespaceName), *(void**)(&name), &result));
        }
        return winrt::winrt_winmd::TypeDef{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_IRootFactory<D>::CreateInstance(param::vector_view<hstring> const& fileNames) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::IRootFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::IRootFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRootFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&fileNames), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::IRootFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&fileNames), &value));
        }
        return winrt::winrt_winmd::Root{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::IsValid() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsValid(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_IsValid(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::IsInterface() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsInterface(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_IsInterface(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::IsStruct() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsStruct(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_IsStruct(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::IsEnum() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsEnum(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_IsEnum(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::HasGenericParams() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasGenericParams(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_HasGenericParams(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::Name() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_Name(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::Namespace() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Namespace(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_Namespace(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::FieldList() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FieldList(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_FieldList(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Field>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::InterfaceImpls() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InterfaceImpls(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_InterfaceImpls(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::InterfaceImpl>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::CustomAttributes() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_CustomAttributes(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::MethodList() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MethodList(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_MethodList(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::MethodDef>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::PropertyList() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PropertyList(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_PropertyList(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Property>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeDef<D>::EventList() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeDef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeDef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EventList(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeDef>**)this;
            check_hresult(_winrt_abi_type->get_EventList(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Event>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeRef<D>::TypeName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeRef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeRef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeRef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TypeName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeRef>**)this;
            check_hresult(_winrt_abi_type->get_TypeName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeRef<D>::TypeNamespace() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeRef>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeRef, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeRef>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TypeNamespace(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeRef>**)this;
            check_hresult(_winrt_abi_type->get_TypeNamespace(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::HasTypeDef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasTypeDef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_HasTypeDef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::TypeDef() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TypeDef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_TypeDef(&value));
        }
        return winrt::winrt_winmd::TypeDef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::HasTypeRef() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasTypeRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_HasTypeRef(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::TypeRef() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TypeRef(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_TypeRef(&value));
        }
        return winrt::winrt_winmd::TypeRef{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::HasElementType() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasElementType(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_HasElementType(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::ElementType() const
    {
        winrt::winrt_winmd::ElementType value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ElementType(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_ElementType(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::HasGenericTypeIndex() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasGenericTypeIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_HasGenericTypeIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::GenericTypeIndex() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GenericTypeIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_GenericTypeIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::HasGenericTypeInstSig() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasGenericTypeInstSig(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_HasGenericTypeInstSig(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::GenericTypeInstSig() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GenericTypeInstSig(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_GenericTypeInstSig(&value));
        }
        return winrt::winrt_winmd::GenericTypeInstSig{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::HasGenericMethodTypeIndex() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasGenericMethodTypeIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_HasGenericMethodTypeIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::GenericMethodTypeIndex() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GenericMethodTypeIndex(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_GenericMethodTypeIndex(&value));
        }
        return value;
    }
    template <typename D> auto consume_winrt_winmd_ITypeSig<D>::IsArray() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::winrt_winmd::ITypeSig>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::winrt_winmd::ITypeSig, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsArray(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::winrt_winmd::ITypeSig>**)this;
            check_hresult(_winrt_abi_type->get_IsArray(&value));
        }
        return value;
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IConstant> : produce_base<D, winrt::winrt_winmd::IConstant>
    {
        int32_t __stdcall get_Type(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::ConstantType>(this->shim().Type());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Valid(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Valid());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ValueInt32(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().ValueInt32());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ValueUInt32(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ValueUInt32());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::ICustomAttribute> : produce_base<D, winrt::winrt_winmd::ICustomAttribute>
    {
        int32_t __stdcall get_TypeNamespace(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().TypeNamespace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TypeName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().TypeName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Value(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::CustomAttributeSig>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::ICustomAttributeSig> : produce_base<D, winrt::winrt_winmd::ICustomAttributeSig>
    {
        int32_t __stdcall get_FixedArgs(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::FixedArgSig>>(this->shim().FixedArgs());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NamedArgs(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::NamedArgSig>>(this->shim().NamedArgs());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IElemSig> : produce_base<D, winrt::winrt_winmd::IElemSig>
    {
        int32_t __stdcall get_HasSystemType(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasSystemType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SystemType(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().SystemType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasStringValue(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasStringValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StringValue(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().StringValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasInt32Value(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasInt32Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Int32Value(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Int32Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasUInt32Value(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasUInt32Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UInt32Value(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().UInt32Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasUInt16Value(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasUInt16Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UInt16Value(uint16_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint16_t>(this->shim().UInt16Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasByteValue(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasByteValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ByteValue(uint8_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint8_t>(this->shim().ByteValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IEvent> : produce_base<D, winrt::winrt_winmd::IEvent>
    {
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CustomAttributes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>>(this->shim().CustomAttributes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasEventTypeDef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasEventTypeDef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EventTypeDef(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeDef>(this->shim().EventTypeDef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasEventTypeRef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasEventTypeRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EventTypeRef(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeRef>(this->shim().EventTypeRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasGenericTypeInstSig(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasGenericTypeInstSig());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GenericTypeInstSig(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::GenericTypeInstSig>(this->shim().GenericTypeInstSig());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IField> : produce_base<D, winrt::winrt_winmd::IField>
    {
        int32_t __stdcall get_Constant(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::Constant>(this->shim().Constant());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CustomAttributes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>>(this->shim().CustomAttributes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Signature(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::FieldSig>(this->shim().Signature());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IFieldSig> : produce_base<D, winrt::winrt_winmd::IFieldSig>
    {
        int32_t __stdcall get_Type(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeSig>(this->shim().Type());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IFixedArgSig> : produce_base<D, winrt::winrt_winmd::IFixedArgSig>
    {
        int32_t __stdcall get_HasElemSigs(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasElemSigs());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ElemSigs(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::ElemSig>>(this->shim().ElemSigs());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasElemSig(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasElemSig());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ElemSig(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::ElemSig>(this->shim().ElemSig());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IGenericTypeInstSig> : produce_base<D, winrt::winrt_winmd::IGenericTypeInstSig>
    {
        int32_t __stdcall get_ClassOrValueType(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::ElementType>(this->shim().ClassOrValueType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasGenericTypeDef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasGenericTypeDef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GenericTypeDef(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeDef>(this->shim().GenericTypeDef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasGenericTypeRef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasGenericTypeRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GenericTypeRef(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeRef>(this->shim().GenericTypeRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GenericArgs(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeSig>>(this->shim().GenericArgs());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IInterfaceImpl> : produce_base<D, winrt::winrt_winmd::IInterfaceImpl>
    {
        int32_t __stdcall get_Class(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeDef>(this->shim().Class());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasTypeDef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasTypeDef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TypeDef(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeDef>(this->shim().TypeDef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasTypeRef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasTypeRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TypeRef(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeRef>(this->shim().TypeRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasGenericTypeInstSig(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasGenericTypeInstSig());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GenericTypeInstSig(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::GenericTypeInstSig>(this->shim().GenericTypeInstSig());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CustomAttributes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>>(this->shim().CustomAttributes());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IMethodAttributes> : produce_base<D, winrt::winrt_winmd::IMethodAttributes>
    {
        int32_t __stdcall get_Static(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Static());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Final(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Final());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Virtual(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Virtual());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HideBySig(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HideBySig());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Strict(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Strict());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Abstract(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Abstract());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SpecialName(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().SpecialName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PInvokeImpl(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().PInvokeImpl());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UnmanagedExport(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().UnmanagedExport());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RTSpecialName(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RTSpecialName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasSecurity(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasSecurity());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RequireSecObject(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RequireSecObject());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IMethodDef> : produce_base<D, winrt::winrt_winmd::IMethodDef>
    {
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Flags(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::MethodAttributes>(this->shim().Flags());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SpecialName(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().SpecialName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Signature(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::MethodDefSig>(this->shim().Signature());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ParamList(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Param>>(this->shim().ParamList());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CustomAttributes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>>(this->shim().CustomAttributes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Parent(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeDef>(this->shim().Parent());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IMethodDefSig> : produce_base<D, winrt::winrt_winmd::IMethodDefSig>
    {
        int32_t __stdcall get_ReturnType(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::RetTypeSig>(this->shim().ReturnType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Params(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::ParamSig>>(this->shim().Params());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IMethodSemantics> : produce_base<D, winrt::winrt_winmd::IMethodSemantics>
    {
        int32_t __stdcall get_Semantic(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::MethodSemanticsAttributes>(this->shim().Semantic());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IMethodSemanticsAttributes> : produce_base<D, winrt::winrt_winmd::IMethodSemanticsAttributes>
    {
        int32_t __stdcall get_Setter(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Setter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Getter(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Getter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Other(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Other());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AddOn(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AddOn());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RemoveOn(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RemoveOn());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Fire(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Fire());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::INamedArgSig> : produce_base<D, winrt::winrt_winmd::INamedArgSig>
    {
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Value(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::FixedArgSig>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::INamespace> : produce_base<D, winrt::winrt_winmd::INamespace>
    {
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Classes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>>(this->shim().Classes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Delegates(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>>(this->shim().Delegates());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Enums(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>>(this->shim().Enums());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Interfaces(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>>(this->shim().Interfaces());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Structs(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::TypeDef>>(this->shim().Structs());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IParam> : produce_base<D, winrt::winrt_winmd::IParam>
    {
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Flags(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::ParamAttributes>(this->shim().Flags());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IParamAttributes> : produce_base<D, winrt::winrt_winmd::IParamAttributes>
    {
        int32_t __stdcall get_In(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().In());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Out(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Out());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Optional(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Optional());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasDefault(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasFieldMarshal(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasFieldMarshal());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IParamSig> : produce_base<D, winrt::winrt_winmd::IParamSig>
    {
        int32_t __stdcall get_ByRef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ByRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Type(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeSig>(this->shim().Type());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IProperty> : produce_base<D, winrt::winrt_winmd::IProperty>
    {
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Type(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::PropertySig>(this->shim().Type());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MethodSemantic(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::MethodSemantics>>(this->shim().MethodSemantic());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CustomAttributes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>>(this->shim().CustomAttributes());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IPropertySig> : produce_base<D, winrt::winrt_winmd::IPropertySig>
    {
        int32_t __stdcall get_Type(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeSig>(this->shim().Type());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IRetTypeSig> : produce_base<D, winrt::winrt_winmd::IRetTypeSig>
    {
        int32_t __stdcall get_ByRef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ByRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasType(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Type(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeSig>(this->shim().Type());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IRoot> : produce_base<D, winrt::winrt_winmd::IRoot>
    {
        int32_t __stdcall get_Namespaces(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Namespace>>(this->shim().Namespaces());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Find(void* namespaceName, void* name, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::winrt_winmd::TypeDef>(this->shim().Find(*reinterpret_cast<hstring const*>(&namespaceName), *reinterpret_cast<hstring const*>(&name)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::IRootFactory> : produce_base<D, winrt::winrt_winmd::IRootFactory>
    {
        int32_t __stdcall CreateInstance(void* fileNames, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::Root>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring> const*>(&fileNames)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::ITypeDef> : produce_base<D, winrt::winrt_winmd::ITypeDef>
    {
        int32_t __stdcall get_IsValid(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsValid());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsInterface(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsInterface());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsStruct(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsStruct());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsEnum(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsEnum());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasGenericParams(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasGenericParams());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Namespace(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Namespace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FieldList(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Field>>(this->shim().FieldList());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InterfaceImpls(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::InterfaceImpl>>(this->shim().InterfaceImpls());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CustomAttributes(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::CustomAttribute>>(this->shim().CustomAttributes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MethodList(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::MethodDef>>(this->shim().MethodList());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PropertyList(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Property>>(this->shim().PropertyList());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EventList(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::winrt_winmd::Event>>(this->shim().EventList());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::ITypeRef> : produce_base<D, winrt::winrt_winmd::ITypeRef>
    {
        int32_t __stdcall get_TypeName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().TypeName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TypeNamespace(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().TypeNamespace());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::winrt_winmd::ITypeSig> : produce_base<D, winrt::winrt_winmd::ITypeSig>
    {
        int32_t __stdcall get_HasTypeDef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasTypeDef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TypeDef(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeDef>(this->shim().TypeDef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasTypeRef(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasTypeRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TypeRef(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::TypeRef>(this->shim().TypeRef());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasElementType(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasElementType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ElementType(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::ElementType>(this->shim().ElementType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasGenericTypeIndex(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasGenericTypeIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GenericTypeIndex(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().GenericTypeIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasGenericTypeInstSig(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasGenericTypeInstSig());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GenericTypeInstSig(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::winrt_winmd::GenericTypeInstSig>(this->shim().GenericTypeInstSig());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasGenericMethodTypeIndex(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasGenericMethodTypeIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GenericMethodTypeIndex(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().GenericMethodTypeIndex());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsArray(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsArray());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::winrt_winmd
{
    constexpr auto operator|(ElementType const left, ElementType const right) noexcept
    {
        return static_cast<ElementType>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(ElementType& left, ElementType const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(ElementType const left, ElementType const right) noexcept
    {
        return static_cast<ElementType>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(ElementType& left, ElementType const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(ElementType const value) noexcept
    {
        return static_cast<ElementType>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(ElementType const left, ElementType const right) noexcept
    {
        return static_cast<ElementType>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(ElementType& left, ElementType const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline Root::Root(param::vector_view<hstring> const& fileNames) :
        Root(impl::call_factory<Root, IRootFactory>([&](IRootFactory const& f) { return f.CreateInstance(fileNames); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::winrt_winmd::IConstant> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::ICustomAttribute> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::ICustomAttributeSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IElemSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IEvent> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IField> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IFieldSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IFixedArgSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IGenericTypeInstSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IInterfaceImpl> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IMethodAttributes> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IMethodDef> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IMethodDefSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IMethodSemantics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IMethodSemanticsAttributes> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::INamedArgSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::INamespace> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IParam> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IParamAttributes> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IParamSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IProperty> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IPropertySig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IRetTypeSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IRoot> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::IRootFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::ITypeDef> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::ITypeRef> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::ITypeSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::Constant> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::CustomAttribute> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::CustomAttributeSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::ElemSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::Event> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::Field> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::FieldSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::FixedArgSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::GenericTypeInstSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::InterfaceImpl> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::MethodAttributes> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::MethodDef> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::MethodDefSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::MethodSemantics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::MethodSemanticsAttributes> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::NamedArgSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::Namespace> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::Param> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::ParamAttributes> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::ParamSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::Property> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::PropertySig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::RetTypeSig> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::Root> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::TypeDef> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::TypeRef> : winrt::impl::hash_base {};
    template<> struct hash<winrt::winrt_winmd::TypeSig> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
